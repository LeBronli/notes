#### 开始

1. while与if的不同
   1. while和if都会先执行括号中的式子
   2. 但是while是在执行完之后再检验左边的对象，比如：while(cin >> value)中，while先执行完>>的操作，然后再检验cin是否为false
   3. 但是if是执行完之后再看这个执行是否成功执行

2. 文件重定向


### C++基础
#### 变量和基本类型
##### 字符类型：

1. char这种类型就是为了字符集服务的，普通的char就是为了...字符集
2. 在C++11中，为了兼容其他的字符集，也就是Unicode，还有char16_t和char32_t这两种长的字符类型

##### 符号类型：

1. 像int,short,long和long long都是带符号的
2. 如果想要不带符号，只需要在这些类型名字前面加上unsigned
3. char类型会有点特殊，因为char并不代表这signed char，而是由编译器决定为signed和unsigned两个其中一种，所以使用char的时候如果需要，最好注明是哪一种

##### 选择类型的一些经验准则

1. 当明确知道数值不可能为负数的时候，使用unsigned
2. 如果数值超过了int的尺寸，使用long long而不是long
3. 算术表达式中不要使用char或者bool
4. 浮点运算时用double

##### 类型转换

1. 尽量做显式转换而不是让编译器自己来
2. 不要混用signed和unsigned，因为当signed取负数的时候会出现异常结果，即signed与unsigned混用的时候，signed会自动转换成unsigned，比如signed为-1时，转化为unsigned之后就会变成很大的数

##### 字符和字符串字面值

1. 由单引号括起来的一个字符为char型字面值
2. 由双引号括起来的为字符串型字面值

##### 两类字符程序员不能直接使用

1. 不可打印的字符
2. 在C++中有特殊含义的字符

##### 指定字面值的类型

1. 通过添加下面的后缀和前缀，可以改变整型，浮点和字符型字面值的默认类型
2. 字符串和字符类型使用前缀
   1. u：用在char16_t前，表示Unicode16字符
   2. U：用在char32_t前，表示Unicode32字符
   3. L：用在wchar_t前，表示宽字符
   4. u8：用在char前，表示UTF-8
 3. 整型字面值使用后缀
    1. u/U：使用在unsigned上
    2. l/L：使用在long
    3. ll/LL:使用在long long
 4. 浮点型使用后缀
    1. f/F：使用在float上
    2. l/L:使用在long double上
 5. 这里举一个例子：1E-3F这个数值，实际上是类型为float的1E-3这个数

##### 变量定义：

1. 基本形式是类型说明符，后面跟着一个或者多个变量名组成的列表，变量名以逗号分开，以分号结尾。所以是可以同时声明多个变量的
2. 可以在声明时为一个或多个变量赋值

3. 在C++中，初始化和赋值是完全不同的操作，虽然初始化有时也用等号

##### 初始化方法

1.  列表初始化：也就是用花括号，有下面几种形式
`int units_sold = 0;`
`int units_sold = {0};`
`int units_sold{0};`
`int units_sold(0);`
但是有一个问题，那就是如果花括号中的值有丢失信息的风险时，编译器会报错，也就是说当值要装进变量时需要丢失信息时，编译器会报错，比如下面的情况：
`long double ld = 3.1415926;`
`int a{ld}, b = {ld};`
像这里使用花括号来初始化就会报错，因为如果要初始化，ld需要丢失信息才能装进int，而这是不被花括号允许的，而下面使用括号或者直接赋值的就没有问题，虽然它们也会丢失信息，但是对于他们来说，丢失信息是可以的：
`int c(ld), d = ld;`
2.  默认初始化
    1.  如果在定义变量的时候没有指定初始值，就会进行默认初始化
    2.  一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或者访问此类值会引发错误。

##### 变量声明和定义的关系

1.  为了支持分离式编译，C++语言将声明和定义区分开来
2.  如果想要声明一个变量而不是定义它，就要在变量前面加上extern，而且不要显式地初始化变量，因为一旦这样就会变成定义
3.  在函数体内部，如果试图初始化一个由extern关键字标记的变量，将会引发错误。
4.  变量只能被定义一次，但是可以被声明多次

##### 名字的作用域

1.  作用域是可以嵌套的，内层作用域可以重新定义外层作用域的变量

##### 复合类型

1.  一条声明语句=基本数据类型+声明符列表，每个声明符都命名了一个变量并指定该变量为与基本数据有关的某种类型
2.  上面这句话的后半句话似乎没有意义，因为到目前为止，声明符其实就是变量名，变量类型就是声明的基本数据类型，但是下面的复合类型不是这样
3.  C++中定义了几种复合类型
    1.  引用
    2.  指针
  4. 引用
     1. C++11中新增了一种右值引用，主要用于内置类，我们使用引用这个词是，都是指左值引用
     2. 引用的声明符是&+变量名
     3. 一般初始化变量时，会把初始值拷贝到对象中，但是定义引用时，会把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。
     4. 因为无法让引用重新绑定到另一个对象，因此引用必须初始化
     5. 引用并不是对象，只是为一个已经存在的对象起的另外一个名字
     6. 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的
     `refVal=2`其实就是把2赋值给refVal这个指针所指向的对象
     `int ii=refVal`和ii=ival一样
     7. 因为引用不是对象，所以不能定义引用的引用
     8. 允许一条语句中定义多个引用，但是每个标识符都必须以符号&开头

  5. 指针
     1. 指针和引用相似，实现了对其他对象的间接访问，但是有很多不同之处
        1. 指针本身就是对象，允许拷贝和赋值，而且可以先后指向多个不同对象
        2. 指针不用在定义的时候赋值，如果没有被初始化，会拥有一个不确定的值
     2. 如果需要某个对象的地址，需要用取地址符（&），注意这个和引用不要搞混了
     `int ival = 42;`
     `int *p = &ival;`
     3. 因为引用不是对象，所以不能让指针指向引用
     4. 指针值应该属于下面4中状态之一
        1. 指向一个对象
        2. 指向紧邻对象所占空间的下一个位置
        3. 空指针
        4. 无效指针

     5. 如果指针指向了一个对象，则可以使用解引用符（*）来访问该对象
     6. 可以对解引用的指针赋值，相当于给指针所指向的对象赋值
     7. 在声明中&和*用来组成符合类型，在表达式中，它们是运算符，含义完全不同，可以把他们当成不同的符号看待

     8. 空指针不指向任何对象，在使用一个指针前，代码可以首先检查它是否为空，有一下几种方法
        1. `int *p1 = nullptr;`得到空指针最直接的方法就是用字面值nullptr来初始化指针，这也是C++11引入的方法，原生支持
        2. `int *p2 = 0;`就算p2是指向double类型的对象，也是0代表空指针
        3. `#include cstdlib int *p3 = NULL;`这个其实和第二条一样，因为NULL其实就是定义在cstdlib中的一个预处理变量，所以在使用NULL前要include这个库
        4. 新标准下，尽量用第一种，尽量少用最后一种

     9. 对于两个类型相同的合法指针，可以使用==或者!=来比较它们
     10. void*是一种特殊的指针，他可以存放任意对象的地址

  6. 在写定义的时候，把&和*这两个符号写在紧靠变量名的位置上，避免引起误解
  7. 指向指针的指针
     1. 可以通过*的数量来判断指针的级数
     2. 如果ppi是指向指向int ival这个对象的指针的指针，那么可以用**ppi来得到ival对象

  8. 指向指针的引用
     1. 上面提到过，因为引用不是对象，所以不存在指向引用的指针
     2. 但是指针是对象，所以是存在指向指针的引用的
     3. 当面对一个比较复杂的指针或者引用的声明的时候，从右往左阅读有利于弄清楚它的真实意义，比如int *&r，r是引用，因为靠近变量名的更重要。

##### const限定符

1. const的出现是基于对一种变量的需求，即他的值不能被改变，以防止程序进行过程中改变这个值

2. `const int bufSize = 512;`这样限定后，变量就定义成了一个常量，之后不能再改变，所以const对象必须初始化

3.  如果利用一个对象去初始化另外一个对象，那么它们是不是cosnt都无关紧要
    1.  用非const对象初始化const对象，可以执行，没问题
    2.  用cosnt对象初始化非const对象，也没问题，非const对象也不会因为这样初始化就变成了常量
    
4.  const的作用域
    
    1.  默认情况下，const是仅在一个文件中有用
    2.  所以如果想要只在一个地方定义const对象，并在其他文件中都使用这个const对象，就需要在声明和定义中都使用extern
    
5.  const的引用
    
    1. 引用的类型必须与其所引用对象的类型一致，但是有两个例外
    
       1. 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。
    
          `int i = 42;`
    
          `const int &r1 = i;`这个其实是正确的，因为非const的变量其实是可以变成const的
    
          `const int &r2 = 42;`正确
    
          `const int &r3 = r1 * 2;`正确
    
          `int &r4 = r1 * 2`错误，因为const并不能变成非const
    
       2. 其实上面的法则在不同的基本类型中同样适用
    
          `double dval = 3.14;`
    
          `const int &ri = dval;`正确
    
       3. 理解2中的原因，可以看看编译器到底对这个表达式做了什么
    
          1.  定义了一个`cosnt int temp = dval`这个临时量
          2.  然后再把引用绑定在这个临时量上面
    
6.  指针和const

    1.  与引用一样，只能用指向const对象的指针指向const对象
    2.  但是与引用不同，指针本身也是一个对象，所以const的使用会有两个方向
        1.  指针指向的对象为const，定义时将const放在最前面`const int *p;`
        2.  指针本身是const的，定义时将类型放在前面`int *const p;`
    3.  指针是常量不意味着不能通过指针修改其指向对象的值

##### constexpr和常量表达式

1. 常量表达式指的是值不会改变并且能够在编译过程中就能得到计算结果的表达式
2. 从上面的定义可以看到，常量表达式有不变和编译时就能得到结果这两个要求
3. 在实际过程中，很难判断某个值是不是常量表达式，所以在C++11中，允许将变量声明为constexpr类型，让编译器来检查这个变量是否为常量表达式
4. constexpr放在类型前，和const一样的位置
5. 正常的函数是不能得到常量表达式的，因为要到运行的时候才能得到结果，但是C++11中允许一种特殊的constexpr函数，这种函数足够简单以至于编译的时候就能得到结果，这样就可以用这种函数来初始化constexpr变量了
6. 指针和引用可以定义为constexpr，但是它们的初始值是收到限制的，一个constexpr指针的初始值必须为nullptr或者0，或者是存储某个固定地址中的对象，估计是为了防止未定义的指针让程序崩溃
7. 而且constexpr指针不能指向函数体内的变量，因为这些变量并非存在固定的地址中，随着函数返回，地址会变或者消失，所以必须指向函数体外的变量
8. constexpr仅对指针本身有效，对于它所指向的变量无关

##### 处理类型

1. 类型别名
   1. 类型别名是一个名字，他是某个类型的同义词，可以让复杂的类型名字简单，而且易于理解和使用
   2. 2中方法可以用来定义类型别名，关键字typedef
      1. `typedef double wages;`
      2. `typedef wages base, *p;`这里p相当于double*的别名
   3. typedef作为声明语句的基本数据类型的一部分，和以前的声明语句一样，声明符可以包含类型修饰，从而也能由基本的数据类型构造出符合类型出来
   4. C++11新规定了一种方法：使用别名声明：`using SI = Sales_item;`SI是Sales_item的别名
   5. 只要类型名能够出现的地方，别名就能使用，两者是等价的
   6. 当符合类型的别名和const共用的时候，就会有稀奇古怪的作用
      1. 
2. auto类型说明符
   1. 因为经常很难知道表达式的最终类型，所以C++11中引进了auto这个类型说明符，用它可以替我们分析表达式所属的类型
   2. auto定义的变量必须有初始值
   3. auto一般会忽略顶层const，保留底层const
   4. 如果希望推断出来的auto类型是一个顶层const

3. decltype类型指示符

   1. 对于需求：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值来初始化变量，为了满足这个需求，C++11引入了第二种类型说明符：decltype，它的作用是选择并返回操作数的类型

      `decltype(f()) sum = x;`这里sum的类型是f的返回类型

   2. decltype处理顶层const和引用与auto不太一样

      1. 

   3. 有点东西，等具体碰到再来看



##### 自定义数据结构

1. 定义类型

   1. ```struct Sales_data{```

      ​	`std::string bookNo;`

      ​	`unsigned units_sold = 0;`

      ​	`double revenue = 0.0;`

      `};`

   2. 花括号内的名字必须唯一，但是可以与类外面的名字重复

   3. 写完右花括号后必须加一个分好，因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分好必不可少

   4. C++11新规定，可以为数据成员提供一个类内初始值

2. 使用定义类型

   1. 可以直接将类.成员名当成一个变量来表示

3. 编写自己的头文件

   1. 类一般不定义在函数体内
   2. 头文件通常包含那些只能被定义一次的实体，比如类，const和constexpr变量
   3. 头文件也经常用到其他头文件的功能，比如用到了string的时候要include string.h
   4. 确保头文件多次包含仍能安全工作的常用技术是预处理器，是从C语言那里继承而来的
   5. #include就是一项预处理功能，当预处理器看到#include时，就会用指定的头文件的内容替代#include
   6. 另一种预处理功能是**头文件保护符**，它依赖于预处理变量。预处理变量有两个状态，已定义和未定义，它可以有效地防止重复包含的发生
      1. 这个没太看懂



#### 字符串，向量和数组

##### 命名空间的using声明

1. 有了using声明后，就无须专门的前缀也能使用所需的名字了，形式如下

   `using namespace::name;`，比如说：`using std::cin;`

2. 每个using声明引入命名空间的一个成员

3. 每个名字的声明之间用分号，就算是在同一行

4. 头文件不能用using声明，因为头文件的内容会拷贝到所有引用它的文件中去，所以如果头文件中有某个using声明，那么每个使用了该头文件的文件就都会有这个声明



##### 标准库类型string

1. 使用string必须先包含`#include <string>`这个头文件，它的定义在命名空间std中

2. 初始化string对象

   1. 默认初始化
      1. `string s1;`这样得到的s1是一个空字符串
      2. `string s2(s1);`得到的s2是s1的副本
      3. `string s2 = s1;和2中的等价`
      4. `string s3("value");`s3是字面值"value"的副本，除了最后那个空字符（默认的字符串中会以空字符结尾）
      5. `string s3 = "value";`和4中等价
      6. `string s4(n, 'c');`将s4初始化为n个字符c组成的字符串

3. 直接初始化和拷贝初始化

   1. 用等号来初始化一个变量实际上执行的是拷贝初始化，编译器把等号右边的初始值拷贝到新创建的对象中去
   2. 如果不使用等号就是用的直接初始化
   3. 当只有一个对像时，两种都可以，但是如果要用到多个值来初始化对象，则只能用直接初始化

4. string对象上的操作

   1. 演示表

      1. `os<<s`将s写入到输出流os中，返回os
      2. `is>>s`从is中读取字符串赋值给s，字符串以空白分隔，返回is
      3. `getline(is, s)`从is中读取一行赋值给s，返回is
      4. `s.empty()`
      5. `s.size()`返回字符的个数
      6. `s[n]`返回s中第n个字符的引用
      7. `s1+s2`
      8. `s1=s2`用s2的副本代替s1原来的字符
      9. `s1==s2`
      10. `s1!=s2`
      11. `<, <=, >, >=`利用字符在字典中的顺序进行比较，而且对字母的大小写敏感

   2. 读写string对象

      1. 使用`cin >> s;`中，string对象会自动忽略开头的空白（即空格，换行和制表符），并从第一个真正的字符开始读起，知道遇到下一处空白为止

      2. 这里有一个关键点：空白实际上包括了3中

         1. 空格
         2. 换行
         3. 制表符

      3. 这里也解释了为什么上面使用>>和<<这类操作的时候，返回的是流而不是其他的，因为这样就可以链式地来写，就像下面这样，会非常方便

         `cin >> s1 >> s2 >> s3;`可以一次性分别读入3个字符串

      4. 读取数量未知的string对象，可以用最前面部分提到的那个方法，即while

         ```string word;```

         `while(cin >> word)`

         `		cout << word << endl;`

         1. 也就是利用`cin >> word`操作后返回cin，然后再利用while来检测cin，从而能够知道到底有没有到头

      5. 使用getline读取一整行

         1. 有时我们希望在字符串中保留空白符，就可以用getline来代替>>
         2. getline函数的参数是一个输入流和一个string对象
         3. 函数返回输入流

   3. string的其他操作

      1. string的size函数返回的是string::size_type类型的值
      2. string类以及其他大部分标准库类型都定义了几种配套的类型，体现了标准库类型与机器无关的特性
      3. size函数返回的是无符号的整数类型，所以小心不要混用无符号与有符号
      4. 所以如果有使用size函数就不要使用int了，避免混用这两种类型
      5. 字面值与string对象相加
         1. 字面值不能和字面值相加
         2. 所以如果要将2个字面值和一个string对象加起来，必须是字面值+string+字面值
         3. 为了与C兼容，C++中的字面值与string对象不是同一个类型，所以要千万小心

5. 处理string中的字符

   1. 在头文件cctype中定义了一组标准库函数来处理字符

      1. isalnum(c)
      2. isalpha(c)
      3. iscntrl(c)是否为控制字符
      4. isdigit(c)
      5. islower(c)
      6. isprint(c)是否为可打印字符
      7. ispunct(c)是否为标点符号
      8. isspace(c)是否为空白符（包括空格，制表符和回车符，换行符，进纸符）
      9. isupper(c)
      10. isxdigit(c)
      11. tolower(c)
      12. toupper(c)

   2. C++兼容了C中的标准库，把.h结尾去掉了，但是在前面加上了c，比如C中的name.h头文件，变成了cname，前面的cctype也是一样。最好使用C++的形式

   3. 在string对象中使用for访问对象

      1. for语句的语法是：`for (declaration : expression){}`

      2. 例子

         ```c++
         string str("some string");
         for (auto c : str)
             cout << c << endl;
         ```

   4. 在string对象中使用for改变字符

      1. 和上面只是访问不一样，如果要改变字符的值，就要使用引用了

      2. 示例

         ```c++
         string s("Hello World!");
         
         for (auto &c : s)
             c = toupper(c);
         ```

   5. 只处理一部分字符

      1. 访问string对象的单个字符有2中方式

         1. 下标
         2. 迭代器

      2. 下标运算符（`[]`）接受的输入参数是`string::size_type`类型的值，返回这个位置上字符的引用

         

##### 标准库类型vector

1. 想要使用vector，必须包含相应的头文件：`#include <vector>`
2. C++既有类模板，也有函数模板，vector就是属于类模板
3. 对于类模板，我们需要提供一些额外信息来指定到底实例化成什么样的类，比如vector就需要提供vector内存放的对象的类型
4. 定义和初始化vector对象
   1. 初始化方法
      1. vector<T> v1 默认初始化，空的vector
      2. vector<T> v2(v1)：v2包含所有v1的副本
      3. vector<T> v2 = v1：和2中等价
      4. vector<t> v3(n, val)：包含了n个val值
      5. vector<T> v4(n)：包含n个重复地执行了值初始化的对象
      6. vector<T> v5{a, b, c ...}
      7. vector<T> v5 = {a, b, c ...}
5. 向vector中添加元素
   1. 可以使用v.push_back(i)来在vector末尾加上一个对象
   2. 后面会提到vector会提供方法允许我们进一步提升动态添加元素的性能
   3. 如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环
6. 其他vector操作
   1. 列表
      1. v.empty()
      2. v.size()
      3. v.push_back(t)
      4. v[n]
      5. v1 = v2
      6. v1 = {a, b, c ...}
      7. v1 == v2
      8. <, <=, >, >=
   2. 不能用下标方式来添加元素



##### 迭代器

1. 所有标准容器都可以使用迭代器，但是其中只有少数几种
2. 虽然string严格意义上来说不属于容器类型，但是string也支持很多容器类型类似的操作，比如迭代器
3. 有迭代器的类型会有2个成员
   1. v.begin()返回指向第一个元素的迭代器
   2. v.end()返回指向最后一个元素的下一位置的迭代器，没什么实际含义，仅仅是个标记而已
4. 如果容器为空，则begin和end返回的是同一个迭代器
5. 标准容器迭代器支持的运算符
   1. *iter：返回迭代器iter所指元素的引用
   2. iter->mem：解引用iter并获取该元素的名为men的成员，等价于(*iter).men
   3. ++iter：让iter指向容器的下一元素
   4. --iter：让iter指向容器的上一元素
   5. iter1 == iter2：判断2个迭代器是否相等，如果它们指向的是同一个元素或者它们是同一个容器的尾后迭代器，就相等
   6. 因为end返回的尾后迭代器并不实际指向某个元素，所以不能对齐进行递增或者解引用的操作
6. 一般来说，我们也不知道迭代器的精确类型，而实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型
   1. iterator就是正常的迭代器
   2. const_iterator和常量指针差不多，都是能读取，但是不能修改它所指的元素
7. 如果对象是常量，那么begin和end返回的是const_iterator，如果不是的话，就返回iterator。有时候这种默认行为并不是我们想要的，C++11因此引入了2个新函数，分别是cbegin和cend，也就是不管对象是不是常量，都返回const_iterator
8. 关于->的一个误区：之前一直以为这个只能访问成员，但是这个其实就等于先解引用，再用.，所以它是可以用来使用函数的，比如一个由string组成的vector，就可以利用iter->empty()来看迭代器指向的string对象是不是为空
9. 任何可能改变vector长度的操作，比如v.push_back()，会使迭代器失效
10. vector和string迭代器支持的操作



##### 数组

1. 数组的大小是固定的，这点和vector不一样，其他方面有点类似，这使得它在某些应用中的性能较好，但是也相应地损失了部分灵活性

2. 数组的维度必须是一个常量表达式

3. 数组的类型不允许用auto来推断

4. 数组的元素应为对象，所以不能是引用

5. 如果对数组进行列表初始化（即大括号），可以不用指明维度，编译器会自动计算出来，比如`int a2[] = {0, 1, 2};`

6. 字符数组的特殊性

   1. 可以用字符串字面值来初始化，但是使用时要注意，字面值结尾还有一个空字符，这个空字符也会被拷贝进字符数组，所以大小要加一

7. 不能用数组来初始化数组

8. 复杂的数组声明

   1. 默认情况下，类型修饰符从右向左绑定。
   2. `int *ptrs[10];`从右到左可以看到定义的是大小为10的数组，名字是ptrs，存放的是指向int的指针
   3. `int &refs[10];`这个按照正常理解是存放引用的数组，但是数组的元素必须是对象，所以这是错误的声明
   4. `int (*Parray)[10] = &arr;`这个从有到左理解就不太合理，因为数组的维度是紧跟着被声明的名字的，所以就数组而言，应该从内向外阅读。这里`*Parray`表示Parray是个指针，向右看，可以知道Parray指向的是大小为10的数组，再看左边，知道数组的元素类型为int。所以这个声明的含义是：Parray是一个指向一个int[10]数组对象的指针
   5. `int (&arrRef)[10] = arr;`和4中一样理解，arrRef是指向int[10]数组对象的指针，这个数组对象就是arr
   6. `int *(&array)[10] = ptrs;`从内向外理解那就是：array是一个引用，指向的是一个大小为10，元素为int指针的数组对象。

9. 访问数组元素

   1. 数组的元素也可以通过下标和for来访问
   2. 使用数组下标的时候，通常将其定义为`size_t`类型，这是一种机器相关的无符号类型（其实这里发现C++中的下标使用的都是无符号类型，所以真的要小心int和小标混用的情况）。
   3. `size_t`类型被定义在cstddef头文件中，这是C标准库stddef.h头文件的C++版本
   4. 访问元素这里，除了没有迭代器，和string还有vector是一样的
   5. 和string和vector一样，下标是否合法这是有程序员来负责检查的，而不是编译器，所以要格外小心

10. 指针和数组

    1. 很多使用数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针

    2. 迭代器支持的操作，指针都可以

    3. 为了让获取尾后指针更加方便，C++11引入了两个新函数：begin和end

    4. 示例

       `int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};`

       `int *beg = begin(ia);`

       `int *last = end(ia);`

    5. 这两个函数定义在头文件iterator中

    6. 两个指针相减就是它们之间的距离，但是它们需要是指向同一个数组当中的元素

       `auto n = end(arr) - begin(arr);`n的值是5，也就是arr数组中元素的数量

    7. 两个指针相减的结果是一个名为`ptrdiff_t`的标准库类型，定义在cstddef头文件中的机器相关类型，因为差值可能是负数，所以他是一种带符号类型

    8. 只要指针指向的是数组中的元素，就可以使用下标

       ```c++
       int *p = &ia[2];
       int j = p[1]; j就是p向下一个元素，也就是ia[3]这个元素
       int k = p[-2]; k就是ia[0]那个元素
       ```

11. C风格字符串

    1. 尽管C++支持C风格字符串，但是最好不要使用它们，因为使用起来不方便，而且极易引发程序漏洞，是诸多安全问题的根本原因

    2. C提供了一系列函数来处理C风格字符串，这些函数被定义在cstring头文件中

    3. 函数

       1. strlen(p)：返回p的长度，空字符不计算在内
       2. strcmp(p1, p2)：比较p1和p2是否相等
       3. strcat(p1, p2)：将p2附加到p1之后，返回p1
       4. strcpy(p1, p2)：将p2拷贝给p1，返回p1

    4. 上面这些函数是不负责验证其字符串参数的，比如：

       `char ca[] = {'C', '+', '+'};`

       `cout << strlen(ca) << endl;因为ca这个字符串没有以'\0结尾，所以strlen()函数会一直向下寻找'`

    5. 比较字符串

       1. C++中string对象比较大小是一次比较字母的大小
       2. C中字符串对象比较大小实际上是比较指针的大小，所以如果比较两个字符串名字，结果是未定义的，如果想要像C++一样的比较方法，则需要使用上面提到的strcmp函数

    6. 将s1和s2两个字符串连接起来，两种语言用的方式也不一样

       1. C++中，可以直接使用+：string s3 = s1 + " " + s2;
       2. C中则不能，因为s1和s2在C中代表的是两个指针，指针相加，得到的结果是未定义的，如果要实现一样的功能，则要使用strcat函数

12. 与旧代码的借口

    1. 很多旧代码在string和vector出现之前就有了，或者与C语言的接口处，都是不能使用C++标准库的，为了解决这些问题，C++专门提供了一组功能

    2. 混用string对象和C风格字符串

       1. 允许使用字符串字面值来初始化string对象

       2. 甚至允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值

       3. 但是如果某处需要一个C风格的字符串，不能用string来代替

       4. 不能用string来初始化指向字符的指针，比如：

          ```c++
          string s("Hello, World");
          
          char *str = s; 这是错的
          const char *str = s.c_str();
          ```

       5. 为了完成这个功能，string提供了`c_str`这个成员函数，但是要注意得到的是const，因为它指向的其实就是string内部的字符串，为了防止我们通过这个C风格字符串改变这个string对象

       6. 使用`c_str`函数得到的字符串不会一直有效，如果后续s被改变了，可能就会失效，所以如果想要一直都能使用的字符串，最好将其重新拷贝一份

    3. 使用数组初始化vector对象

       1. 不允许数组来初始化数组

       2. 不允许vector来初始化数组

       3. 但是允许数组来初始化vector

          `int int_arr[] = {0, 1, 2, 3, 4, 5};`

          `vector<int> ivec(begin(int_arr), end(int_arr));`

       4. 可以看到使用两个指针来初始化vector

       5. 也可以只使用数组的一部分来初始化vector：`vector<int> subVec(int_arr+1, int_arr+4);`

       6. 但是我感觉有点问题，因为这两个函数C中会有吗？

       7. 尽量使用标准库而不是数组，因为使用指针和数组很容易出错

    4. 现代的C++程序员应当尽量使用vector和迭代器，避免使用内置数组和指针，应该尽量使用string，避免使用C风格的基于数组的字符串

13. 多维数组

    1. 严格来说，其实C++没有多维数组，只是数组的数组

    2. 理解多维数组时，前面提到的从内到外的阅读顺序有助于理解

    3. 对于二维数组，一般把第一个维度叫行，第二个维度叫列

    4. 多维数组的初始化

       1. 可以用嵌套的大括号来初始化：

          ```c++
          int ia[3][4] = {
              {0, 1, 2, 3},
              {4, 5, 6, 7},
              {8, 9, 10, 11}
          };
          ```

       2. 也可以不适用嵌套：

          ```c++
          int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
          ```

       3. 也可以不初始化所有元素，但是不同的写法会带来不同的结果

          1. 只初始化每一行的第一个元素

             ```c++
             int ia[3][4] = {{0}, {4}, {8}};
             ```

          2. 只初始化第一行的4个元素

             ```c++
             int ix[3][4] = {0, 3, 6, 9}
             ```

          3. 其实我觉得还蛮好理解的，只需要不把他当成二维数组，而是数组的数组就可以了，比如1中的，其实就是传入了3个花括号，每个花括号用来初始化一个元素数组

    5. 使用for来处理多维数组

       1. 示例

          ```c++
          constexpr size_t rowCnt = 3, colCnt = 4;
          int ia[rowCnt][colCnt];
          
          //这是正常的for循环
          for (size_t i=0; i != rowCnt; ++i){
              for (size_t j = 0; j != colCnt; ++j){
                  ia[i][j] = i * colCnt + j;
              }
          }
          
          //但是C++11中新增了范围for语句，所以可以简化成这样
          size_t cnt = 0;
          for (auto &row : ia)
              for (auto &col : row){
                  col = cnt;
                  ++cnt;
              }
          ```

       2. 下标可以看到初始化i和j的时候，使用的类型是size_t，使用下标时都要这样

       3. 主要是范围for语句的用法，有几点要注意

          1. 如果要改变其中的元素，要用引用
          2. 就算不改变元素，还是要将外层循环的控制变量变成引用类型，这是为了避免数组被自动转成指针，因为加入不用引用，程序无法通过编译：
             1. 如果外层的row不是引用类型，编译器初始化row时会自动将这些数组形式的元素转换成指向该数组首元素的指针，这样得到的row的类型就是int*，这样的画，内层的循环就不合法了。
             2. <font color="red">还是不太懂，加了引用符号的话，就不会这样了？其实光是能这样使用for循环就已经让人想不通了</font>
          3. 多使用auto这个类型符

       4. 声明的读法

          1. 没括号：`int *ip[4];`意思是ip是一个含有4个整数指针的数组
          2. 有括号：`int (*ip)[4];`意思是ip是一个指向4个整数的数组
          3. <font color='red'>这两种有区别吗？不是说名字也就是指向第一个元素的指针吗？</font>

       5. 通过使用auto或者decltype，就能尽可能避免在数组前面加上一个指针类型了



#### 表达式

##### 基础

1. C++语言定义了运算符作用于内置类型和符合类型的运算对象时所执行的操作。我们可以重载运算符
2. C++从C那里继承了左值和右值的概念，原本左值指那些可以放在赋值语句左侧的。但是在C++中，当一个对象被用作右值时，用的是对象的值，当对象用作左值的时候，用的是对象的身份（在内存中的位置）



##### 算术运算符

##### 逻辑与关系闭运算符

##### 位运算符

1. 因为有符号的数的符号位在不同的机器上不同，而且位运算也会改变它的符号，所以强烈建议只将位运算运用在无符号数上面
2. <<和>>分别为左移和右移运算符
3. ~是位求反运算符，即将运算对象逐位求反后生成一个新值
4. 使用位运算符时，如果运算对象的位数比整型要小，会自动提升位数



##### sizeof运算符

1. 返回一条表达式或者一个类型名字所占的字节数
2. 返回size_t类型
3. sizeof函数除了传入变量，还能传入表达式，返回运算结果类型所占的字节数，但是它并不运算
4. 一般来说，要知道类成员的大小要知道实例化的对象，但是sizeof不用
5. 因为sizeof返回的是常量，所以我们可以用它的返回值来声明数组的维度



##### 逗号运算符

1. 经常在for循环当中出现，也就是for语句中的最后一句



##### 类型转换

1. 会发生隐式转换的情况
   1. 大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
   2. 在条件中，非布尔值转换为布尔值
   3. 初始化过程中，初始值转换成变量的类型。在赋值语句中，右侧运算对象转换成左侧运算对象的类型
   4. 如果算术运算或者关系运算的运算对象有多种类型，需要转换成同一中类型
   5. 函数调用时也会发生类型转换
   
2. 整型提升

3. 无符号类型的运算对象

   1. 如果运算的两个对象，一个是有符号的，一个是没符号的，如果无符号类型不小于带符号类型，那么带符号的运算对象会变成无符号的，所以如果带符号的值是负数，会带来副作用，因此我们不要将有符号和无符号的数混用
   2. 如果带符号类型大于无符号类型，则

4. 其他隐式转换

   1. 数组转换成指针

      1. 在大多数用到数组的表达式中，数组自动转换成指向第一个元素的指针
      2. 但是在一下情况中，这种隐式转换不会发生：
         1. 用作decltype的关键参数
         2. 作为取地址符（&），sizeof，和typeid等运算符的运算对象时
         3. 用一个引用来初始化数组
      3. 2.2中也就是为什么在使用for遍历数组是，就算不改变元素，除了最内层的循环，其他外层都要用引用，就是为了防止这种隐式转换

   2. 指针转换

      1. 常量整数值0或者字面值nullptr能转换成任意指针类型
      2. 指向任意非常量的指针能转换成void*
      3. 指向任意对象的指针能转换成const void *

   3. 转换成布尔类型

   4. 转换成常量

   5. 类类型定义的转换

      1. 类类型能定义由编译器自动执行的转换

      2. 不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝

      3. 例子：

         `string s = "a value";`这里其实就是用了这个转换，将字符串字面值转换成了string类型

         `while (cin >> s)`将istream转换成了布尔值

5. 显式转换

   1. 强制类型转换的形式
      1. `cast-name<type>(expression);`
      2. type是转换的目标类型
      3. expression是要转换的值
      4. cast-name有以下几种，指定执行的是哪种转换
         1. `static_cast`
            1. 任何有明确定义的类型转换，只要不包含底层const，都可以使用这个
            2. `double slope = static_cast<double>(j) / i;`
            3. 当需要把一个较大类型的转换成较小类型的时候，这个很有用，因为这个告诉编译器：我不在乎损失一些精度，这样原本会有的警告就会消失。
         2. `const_cast`
            1. 只能改变运算对象的底层const
            2. 通常用在有函数重载的上下文中，后面会详细说
         3. `reinterpret_cast`
            1. 通常为运算对象的位模式提供较低层次上的重新解释
            2. 非常危险
            3. 看不懂
         4. `dynamic_cast`
            1. 支持运行时类型识别，后面会详细讲到
      5. 应该尽量避免强制类型转换
      6. 也可以使用旧式的C风格的强制类型转换



#### 语句

##### 简单语句

1. 复合语句是指用花括号括起来的语句和声明的序列，也别叫做块

   

##### 语句作用域

##### 条件语句

1. switch语句

   1. case关键字和它对应的值一起被称为case标签，它必须是**整型常量表达式**

   2. 这个语句并不会像if一样，执行了一个case之后就不执行其他case。相反，它会继续向下执行，所以为了避免这种情况，应该在每个case中加入break语句

   3. 但是2中的特性也可以利用起来，在case语句中使用不完全exclusive的表达式

   4. 可以把几个case值放在一起：`case 'a': case'e': case 'i': ++vowelCnt; break;`

   5. 如果没有一个case标签可以匹配switch表达式中的值，程序会执行default标签后面的语句

   6. 示例

      ```c++
      switch (ch){
          case 'a':
              ++aCnt;
              break;
          case 'b':
              ++bCnt;
              break;
      }
      ```

##### 迭代语句

1. for语句头中定义的对象只能在for循环体中可见
2. for语句头中定义语句只能有一句，但是可以初始化多个变量，也就是说这些变量的类型要相同

##### 跳转语句

1. break语句负责终止离他最近的while，do while, for或者switch语句

2. continue语句终止最近的循环中的当前迭代并立即开始下一次迭代，所以只能在循环语句中使用，在switch语句这种里面不能用

3. goto语句

   1. 语法：`goto label;`

   2. 其中label是用于标识一条语句的标识符。

   3. 带标签语句是一种特殊的语句，它前面有一个标识符还有一个冒号：`end: return;`

   4. 标识符的标签名是独立于变量和其他标识符的名字，命名时可以有更多选择

   5. goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内（应该是为了安全，不能把控制权转移到作用域之外）

   6. 可以向前也可以向后跳，但是不能向后跳过带初始化的变量定义：

      ```c++
      goto end;
      int ix = 10; //错误的，因为跳过了这种语句
      
      end: 
      	ix=42; 
      ```

      ```c++
      begin:
      	int sz = get_size();
      	if (sz <= 0){
              goto begin;  //合法的，因为goto语句会销毁sz变量，所以不会出现重复声明的情况
          }
      ```

##### try语句块和异常处理

1. throw表达式

   1. 使用这个表达式来抛出异常

   2. 真实的程序中，应该把调试的代码和用户交互的代码分离开来，所以通常用抛出异常而不是打印出异常信息

   3. 示例：

      ```c++
      if (...)
          throw runtime_error("Data must refer to same ISBN");
      ```

   4. runtime_error是标准库异常类型的一种，定义在stdexcept头文件中

2. try语句块

   1. 通用语法

      ```c++
      try {
          program-statements
      } catch (exception-declaration){ //举个例子：是runtime_error err而不只是单纯的类型符
          handler_statements
      } catch (exception-declaration){
          handler_statements
      }...
      ```

   2. 如果没有找到匹配的catch子句，程序转到名为`terminate`的标准库函数，这个函数的行为与系统有关，一般会导致程序非正常退出



#### 函数

##### 函数基础

1. 执行函数的第一步是定义并初始化它的形参
2. 遇到return语句后结束执行进程，return语句有两个作用
   1. 返回return语句中的值
   2. 将控制权从被调函数移回主调函数
3. 函数返回值不能是数组和函数，但是可以是指向它们的指针
4. 局部对象可分成几种
   1. 自动对象：形参和函数内定义的普通对象，在函数执行后，会被销毁
   2. 局部静态对象：有时我们想让局部变量在函数返回后依然存在，可以将局部变量定义为static类型
5. 函数声明
   1. 函数可以被声明多次，但是只能被定义一次
   2. 声明时没有函数体，直接用分号结束
   3. 因为不包括函数体，形参不需要名字，只要类型符就行，但是也可以加上名字，两种都可以

##### 参数传递

1. 形参的类型决定了形参和实参的交互方式

   1. 形参是引用类型，将绑定在对应的实参上
   2. 形参不是引用类型，就会将实参的值拷贝后赋值给形参

2. 传引用参数

   1. 例子

      ```c++
      void reset(int &i){
          i = 0;
      }
      
      int j = 42;
      reset(j);
      ```

   2. 上面的例子可以看到，i是j的一个别名

   3. 实参并不需要是引用，只需要形参在声明时声明是引用即可

   4. 有时使用引用并不是要改变其的值，而是使用引用可以避免拷贝，对于一些比较大的值，使用引用也是一个好的选择

   5. 还可以利用引用来实现返回多个值，因为C++的return并不能像Python一样返回多个值，所以可以传入引用，然后改变引用的值，从而实际返回多个值（其实就是C中的用法）

   6. const形参和实参

      1. 形参是可以使用const的，因为是初始化，而不是再赋值
      2. 使用引用而不是常量引用会限制函数能接受的实参的范围：因为可以用非const对象初始化const对象，而反过来则不行

   7. 数组形参

      1. 数组有2个性质对于这里有影响

         1. 不允许拷贝数组
         2. 使用数组时，通常会将其转换成指针

      2. 我们无法使用值传递来使用数组参数，因为数组会被隐式转换成指针

      3. 所以可以用下面几种形式，这样就能看出参数是数组

         ```c++
         void print(const int[]);
         void print(const int[10]);
         ```

      4. 但是调用函数不知道数组的其他信息，比如说长度之类的，为了解决这个问题，有几种方案

         1. 包含一个结束标记，比如C风格字符串，最后一个字符是空字符
         2. 使用标准库规范，也就是传递指向数组首元素和尾后元素的指针
         3. 显式地传递一个表示数组大小的实参

      5. 因为变量可以定义为数组的引用，所以形参也可以这样

         1. 注意写法：是`int (&arr)[10]`而不是`int &arr[10]`，因为后者表示的是引用的数组，因为引用不是对象，所以不存在引用的数组，后者是错误的

      6. 传递多维数组

         1. 因为C++中没有真正的多维数组，有的只是指向数组的指针的数组，所以传入多维数组实际上可以写作：`int (*matrix)[10]`这种，也就是指向数组的指针的指针
         2. 也可以用这种：`int matrix[][10]`，因为编译器会忽略掉第一个维度，所以第一个方括号内不要写数字

   8. main函数处理命令行选项

      1. 两个可选的形参
         1. `int argc`
         2. `char *argv[]`也可以写作：`char **argv`
      2. 第一个形参表示第二个形参数组的数量，也就是上面提到的解决方案的第3条

   9. 可变形参

      1. 为了应对不同长度的实参，有几种方法：

         1. 所有实参类型相同：传递名为`initializer_list`的标准库类型

            1. 是一种标准库类型，表示某种特定类型的值的数组

            2. 提供的操作

               1. `lst2 = lst1 / lst2(lst1)`：将lst1赋值给lst2，但是并不会拷贝，赋值过后，两个对象共享元素
               2. `lst.size()`
               3. `lst.begin()`
               4. `lst.end()`

            3. initializer_list也是一种模板类型，定义时，要说明列表中所含元素的类型

            4. 与vector的区别：initializer_list对象中的元素都是常量值，我们无法改变

            5. 可以使用begin和end这两个成员方法来遍历initilizer_list对象

               ```c++
               void error_msg(initializer_list<string> il){
                   for (auto beg = il.begin(); beg != il.end(); ++beg)
                       cout << *beg << " ";
                   cout << endl;
               }
               ```

            6. 含有这个形参的函数还可以有其他形参

               ```c++
               void error_msg(ErrCode e, initializer_list<string> il){
                   ...
               }
               
               error_msg(ErrCode(42), {"functionX", expected, actual});
               ```

         2. 实参类型不同：编写特殊的函数，也就是可变参数模板

         3. 还有一种特殊的形参类型，也就是**省略符**，但是它一般只用于与C语言交互的接口程序

            1. 使用了名为varargs的C标准库功能
            2. 大多数类类型的对象在传递给省略符形参的时候都没办法正常拷贝，所以使用类的时候不哟啊用这个

##### 返回类型和return语句

1. return可以不接表达式，但是只能在返回类型为void的函数中，在这种函数中，不要求非得有return语句，因为他会在最后隐式地执行return语句

2. 不要返回局部变量的引用或者指针，因为函数执行完毕后，它所占的存储空间也随之被释放掉

3. C++新标准规定，可以返回花括号保卫的值的列表，也就是可以返回多个值了，但是是一个vector，也就是说类型要相同，如果要返回类型不同的多个值，还是要用C语言的那一套，也就是改变引用实参

4. 虽然main函数不是void返回类型，但是我们允许它没有return语句直接结束

5. 因为数组不能被拷贝，所以不能直接返回数组，但是可以返回数组的引用或者指向数组的指针，但是这样没法声明数组的大小，下面有几种解决方案

   1. 使用类型别名

      ```c++
      //两种将arrT声明为int[10]的别名的方法
      typedef int arrT[10];
      using arrT = int[10];
      
      arrT* func(int i);
      ```

      

   2. 不太懂，这个











##### 函数重载

1. 函数重载的几点要求
   1. 同一作用域
   2. 函数名字相同
   3. 形参列表不同
   
2. main函数不能重载

3. 一个拥有顶层const的形参无法和一个没有顶层const的形参区分开来，其实就是一个无法变化的指针和一个可以变化的指针是一样的，因为在实际使用中没有区别，一般并不需要改变指针自己的值

4. 但是如果是底层的const就和非const有区别了

5. 按理来说，是可以将非const的实参传入const的形参的，因为这样的类型转换是合法的，但是在传入一个非常量实参的时候，编译器会优先选用常量形参

6. 重载函数中可能会比较多地用到前面类型转换中的`const_cast`，因为有时我们希望传入非const，返回非const，传入const，返回const

   ```c++
   //为了实现这个目标，我们只需要实现一次这个函数即可：
   const string &shorterString(const string &s1, const string &s2){
       return sz.size() <= s2.size() ? s1 : s2;
   }
   
   //重载函数只需要再调用上面的函数，然后在将其结果转为非const然后返回即可
   string &shorterString(string &s1, string &s2){
       auto &r = shorterString(const_cast<const string&>(s1),
                              const_cast<const string&>(s2));
       return const_cast<string&>(r);
   }
   ```

7. 对于参数数量一致，而且类型可以互相转化的时候，编译器的处理方法：

   1. fd





##### 特殊用途语言特性

1. 默认实参也就是可以在形参类表中设定默认值

2. 一次函数包含着一系列工作，所以其实有一定的开销，内联函数可以避免这些

   1. 将函数指定为内联，其实就是将它在每个调用点上内联地展开，有点像宏，应该是编译器自动将其替换为相应的代码
   2. 在函数定义前面加上关键字**inline**，就可以将其声明为内联函数了
   3. 一般来说，内联函数用于优化规模较小，流程直接，频繁调用的函数，很多编译器都不支持

3. constexpr函数是指能用于常量表达式的函数

   1. 要遵循的约定：
      1. 函数返回的类型以及所有形参的类型都得是字面值类型
      2. 函数体内必须有且只有一条return语句
      3. 为了能在编译时展开，constexpr函数被隐式地指定为内联函数

4. 内联函数和constexpr函数通常定义在头文件

5. 调试帮助

   1. 也就是用户使用时，会屏蔽掉调试代码

   2. assert

      1. 他是一种预处理宏
      2. 使用一个表达式来作为它的条件
      3. 如果表达式为假，assert输出信息并终止程序的执行
      4. 定义在cassert头文件中
      5. 预处理名字由预处理器而不是编译器管理，所以我们不需要声明它，也就是应该使用`assert而不是std::assert`
      6. 常用于检查“不能发生”的条件

   3. NDEBUG预处理变量

      1. assert的行为取决于这个变量

      2. 定义了NDEBUG，则assert什么都不做

      3. 默认状态下没有定义NDEBUG，所以assert将执行运行时检查

      4. 我们可以使用#define语句来定义NDEBUG，从而关闭调试状态，或者通过命令行选项：

         `//命令的作用相当于在文件一开始写#define NDEBUG`

         `CC -D NDEBUG main.C`

      5. 还可以利用这个变量做一些事：

         ```c++
         void print(const int ia[], size_t size){
             #ifndef NDEBUG
                 cerr << __func__ << ": array size is " << size << endl;
             #endif
             //...
         }
         ```

      6. 除了C++编译器定义的`__func__`之外，预处理器还定义了另外4个对于程序调试有用的名字，它们可以在调试中提供更多信息

         1. `__FILE__`：存放文件名的字符串字面值
         2. `__LINE__`：存放当前行号的整型字面值
         3. `__TIME__`：存放文件编译时间的字符串字面值
         4. `__DATE__`：存放文件编译日期的字符串字面值

##### 函数匹配

1. 

##### 函数指针

1. 函数指针指向函数而非对象

2. 函数的类型由下面两个决定，与函数名无关

   1. 返回类型
   2. 形参类型

3. 示例，有几个点需要注意：

   1. 指针两边的括号是不能省的
   2. 并没有给形参取名，这个也要注意

   ```c++
   bool lengthCompare(const string&, const string&);
   
   //这里定义一个指针
   bool (*pf)(const string &, const string &);
   ```

4. 我们可以使用取地址符和函数名来初始化指针：`pf = &lengthCompare;`，但是其实取地址符是可选的，有没有都可以

5. 使用指针调用函数

   1. 无须提前解引用指针

   2. 有几种不同的使用方法：

      ```c++
      bool b1 = pf("hello", "goodbye");
      bool b2 = (*pf)("hello", "goodbye");
      bool b3 = lengthCompare("hello", "goodbye");
      ```

6. 在为函数指针赋值的时候，重载函数要注意一下：

   1. 编译器通过指针类型决定选用哪个函数，指针类型必须和重载函数中的一个精确匹配

      ```c++
      void ff(int*);
      void ff(unsigned int);
      
      void (*pf1)(unsigned int) = ff;
      ```

7. 函数的形参可以是指向函数的指针，此时形参看起来是函数类型，但是却被当成指针使用，有点像数组

   ```c++
   //第三个形参会自动转换成指向函数的指针
   void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));
   
   //等价的声明
   void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));
   ```

8. 我们可以直接把函数当做实参使用，这时他会自动转换成指针：`useBigger(s1, s2, lengthCompare);`

9. 因为函数指针的类型太长了，所以我们可以使用类型别名和decltype来简化代码

   1. 还是要区分一下，这样得到的是函数类型

      ```c++
      typedef bool Func(const string&, const string&);
      typedef decltype(lengthCompare) Func2;
      using F = int(int*, int);
      ```

   2. 这样得到的是函数指针类型

      ```c++
      typedef bool(*FuncP)(const string&, const string&);
      typedef decltype(lengthCompare) *FuncP2;
      using PF = int(*)(int*, int);
      ```

10. 返回指向函数的指针

    1. 和数组一样，虽然函数不能返回函数，但是能返回指向函数的指针
    2. 但是必须要显式地将返回类型写成指针类型，因为编译器不会自动地将函数返回类型当成对应的指针类型处理

11. 将auto和decltype用于函数指针类型



#### 类

##### 定义抽象数据类型

1. 类的基本思想是：
   1. 数据抽象：是一种依赖于接口和实现分离的编程技术
   2. 封装：
   
2. 定义在类内部的函数是隐式的inline函数

3. 定义成员函数
   
   1. this是一个常量指针，我们不允许改变this中保存的地址
   
4. 在类外部定义成员函数

   1. 返回类型，参数列表，函数名都必须与前面声明的一致
   2. 要声明类这个作用域
   3. 如果是常量函数，需要在参数列表后面加上const：`double Sales_data::avg_price() const{}`

5. 牵涉到两个对象的成员函数，它的`this`所指的是调用这个函数的对象

6. 如果需要`this`来返回调用对象，应该使用`return *this`这样的语句

7. 定义类相关的非成员函数

   1. 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内
   2. IO类型是不能被拷贝的，所以我们使用它们时，只能使用引用来使用

8. 构造函数

   1. 构造函数与类的名字相同

   2. 与其他函数不同的地方在于：

      1. 构造函数没有返回类型
      2. 构造函数不能被声明为const

   3. 类通过一个特殊的构造函数来控制默认初始化进程，叫做默认构造函数，它不需要任何实参

   4. C++中使用struct来定义类

   5. 示例代码

      ```c++
      struct Sales_data{
          Sales_data() = default;
          Sales_data(const std::string &s): bookNo(s) {}
          Sales_data(const std::string &s, unsigned n, double p):
          	bookNo(s), units_sold(n), revenue(P*n) {}
          Sales_data(std:istream &);
          
          //其他成员
          std::string isbn() const {return bookNo;}
          Sales_data& combine(const Sales_data&);
          double avg_price() const;
          std::string bookNo;
          unsigned units_sold = 0;
          double revenue = 0.0;
      };
      ```

   6. 类定义的花括号后面还有个分号

   7. 第一行中`=default`是指默认构造函数，也就是告诉编译器自己来生成构造函数

   8. 参数列表的冒号和花括号之间的部分是**构造函数初始值列表**

      1. 它们负责为对象的一个或几个数据成员赋值
      2. 不同成员用逗号隔开

   9. 类外部定义构造函数

      1. 感觉没啥区别

9. 拷贝，赋值和析构

   1. 类除了初始化之类的操作，还需要定义拷贝，赋值和销毁等操作
   2. 如果自己不定义，编译器会替我们合成它们
   3. 一般来说，编译器默认是对类的每个成员执行拷贝赋值和销毁操作
   4. 后面会提到高级的操作

##### 访问控制与封装

1. 到现在为止，类中的成员仍然能够被用户直接获取，因为我们没有进行封装

2. 在C++中，我们使用**访问说明符**来加强类的封装性

   1. public说明成员在整个程序内可以被访问

   2. private说明只能被类的成员函数访问

   3. 示例

      ```c++
      class Sales_data{
      public:
          Sales_data() = default;    
          Sales_data(const std::string &s): bookNo(s) {}    
          Sales_data(const std::string &s, unsigned n, double p):        
          bookNo(s), units_sold(n), revenue(P*n) {}    
          Sales_data(std:istream &);   
          std::string isbn() const {return bookNo;}    
          Sales_data& combine(const Sales_data&);
      public:
          double avg_price() const;   
        	std::string bookNo;    
          unsigned units_sold = 0;    
          double revenue = 0.0;
      };
      ```

3. 上面的例子中，我们使用struct来定义类，但是我们其实也可以通过关键字**class**来定义，它们的区别在于默认访问权限不一样

   1. 使用struct，则在第一个访问说明符之前的成员是public的，其实很好理解，因为在C中，struct就是用来定义数据块的，自然是默认全部可以直接访问了
   2. 使用class，则在第一个访问说明符之前的成员是private的
   3. 为了编程风格的一致，如果希望类的所有成员都是public的，那就用struct，不然用class

4. private带来的问题是：那些需要访问成员的非成员函数不能编译通过，C++的解决方案是**友元(friend)**

   1. ```c++
      class Sales_data{
      friend Sales_data add(const Sales_data&, const Sales_data&);
      friend std::istream &read(std::istream&, Sales_data&);
      friend std::ostream &print(std:ostream&, const Sales_data&);
          
      ...
      }
      ```

   2. 其实也就是在类中声明这些函数可以访问这个类的private成员

   3. 友元的声明只是指定了访问的权限，如果我们希望能调用这个函数，则要在友元声明之外再进行一次声明。

##### 类的其他特性

1. 别名

   1. 类中可以自定义某种类型在类中的别名
   2. 要放在public的最前面，因为要先定义再使用

2. 类中经常有规模较小的函数适合被声明为内联函数

   1. 定义在类内部的成员函数是自动inline的

3. 成员函数也能被重载，只需要函数之间在参数的数量和或类型上有所区别就好

4. 可变数据成员

   1. 声明符为mutable

   2. 就算对象是const的，该对象内声明为mutable的成员也可以被改变

   3. 声明为const的函数同样也可以改变mutable的成员

   4. 示例

      ```c++
      class Screen{
      public:
          void some_member() const;
        
      private:
          mutable size_t access_ctr;
      }
      ```

5. 返回`*this`的成员函数

   1. 返回`*this`还是很有用的，因为这样就可以使用链式语法了：`myScreen.move(4, 0).set('#');`，也就是可以在一行内进行多次操作，很方便
   2. 一个const成员函数如果返回`*this`，那么它的返回类型将是一个常量引用，也就不能进行所有的链式语法（如果后面有改变的行为）

6. 类类型

   1. 可以只声明类而暂时不定义它，这种叫做**前向声明**，在它声明之后定义之前，这种类型是一个不完全类型，不完全类型的使用场景很有限

7. 友元

   1. 除了可以将非成员函数定义为友元，还可以把下面这些定义为友元
      1. 其他类
      2. 其他类的友元
   2. 友元不具有传递性，也就是友元的友元不是友元
   3. 当把成员函数声明为友元时，我们必须明确指出该成员函数属于哪个类
   4. 如果想要把一组重载函数声明为它的友元，需要对这些函数一个一个地分别声明，因为声明友元时，会指出形参和返回类型，而不只是函数名
   5. 友元声明中的非成员函数和类不一定要在友元声明前就声明好，因为友元声明的作用是影响访问权限，本身并非普通意义上的声明

##### 类的作用域

1. 

##### 构造函数再探

1. 初始化

   1. 在很多类里面，初始化和赋值和效率有关，因为赋值实际上是先初始化再赋值
   2. 除了效率问题之外，有些数据成员必须初始化，比如引用和const变量，所以应该养成使用构造函数初始值的习惯，可以避免很多编译错误
   3. 成员初始化的顺序
      1. 构造函数的初始值列表只说明用于初始化成员的值，不限定初始化的具体执行顺序
      2. 成员的初始化顺序实际上与它们在类定义中的出现顺序一样
      3. 一般对于这个顺序没什么要求，但是如果一个成员以另一个成员来初始化，那么顺序就很关键了
      4. 

2. 委托构造函数

   1. 把自己的构造职责委托给了其他构造函数

   2. 和其他构造函数一样，一个委托构造函数也只有一个成员初始值的列表和一个函数体

   3. 示例

      ```c++
      class Sales_data{
      public:
          Sales_data(std::string s, unsigned cnt, double price): 
          	bookNo(s), units_sold(cnt), revenue(cnt*price) {}
          
          //其余构造函数全部委托给了另一个构造函数
          Sales_data(): Sales_data("", 0, 0){}
          Sales_data(std::string s): Sales_data(s, 0, 0) {}
          Sales_data(std::istream &is): Sales_data() {read(is, *this);}
      }
      ```

   4. 其实就是重载函数的时候可以轻松点

   5. 当一个构造函数委托给另一个构造函数时，被委托函数的初始值列表和函数体被依次执行，然后再执行委托构造函数自己的函数体

   6. 所以委托构造函数还是可以自定义初始值列表？

3. 默认构造函数的作用

   1. 

4. 隐式的类类型转换

   1. 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制，我们把这类构造函数称为**转换构造函数**

   2. 示例

      1. 这里combine的使用是合法的，因为前面定义的Sales_data这个类的构造函数中有只接受string类型的函数，也就是上面提到的转换构造函数
      2. 其实就是编译器自动将string变成一个临时的Sales_data对象，传递给combine这个成员函数，在这个函数完成之后，这个临时对象就不能被访问了

      ```c++
      string null_book = "9-999-99999-9";
      
      item.combine(null_book);
      ```

   3. 编译器只能自动地执行一步类型转换，下面的代码隐式地使用了两种转换规则，所以是错误的

      1. 其实就是字符串字面值不是string，所以其实用了2步：字符串字面值->string对象->Sales_data对象，所以是错误的

         ```c++
         item.combine("9-999-99999-9")''
         ```

   4. 有时这种隐式转换并不是我们想要的，可以通过`explicit`来加以阻止

      1. 示例

         ```c++
         class Sales_data{
         public:
             Sales_data() = default;
             Sales_data(const std::string &s, unsigned n, double p):
             	bookNo(s), units_sold(n), revenue(p*n) { }
             explicit Sales_data(const std::string &s): bookNo(s) {}
             explicit Sales_data(std::istream&);
         };
         ```

      2. 这样声明之后就不能通过隐式创建`Sales_data`对象了。之前的几种用法都没办法通过编译

      3. 只有对于一个实参的构造函数，编译器才会隐式地转换

      4. 所以explicit这个关键字只对那些只有一个实参的函数有效

      5. 那些多于一个实参的构造函数，编译器并不会隐式地转换

   5. 为转换显式地使用构造函数

      1. 对于声明为explicit的构造函数，虽然不能隐式地转换，但是可以显式地强制转换

      2. 示例

         ```c++
         //错误，因为声明后不会隐式地转换
         item.combine(null_book);
         
         //正确
         item.combine(Sales_data(null_book));
         
         //正确，因为static_cast可以使用explicit的构造函数
         item.combine(satetic_cast<Sales_data>(cin));
         ```

      3. 标准库中含有显式构造的类

         1. 接受字符串字面值（const char*）的string构造函数不是explicit的
         2. 接受容量参数的vector构造函数是explicit的

5. **聚合类**

   1. 聚合类的特点：
      1. 可以让用户直接访问其成员
      2. 具有特殊的初始化语法形式
   2. 满足下面的条件的类是聚合类
      1. 所有成员都是public的
      2. 没有定义任何构造函数
      3. 没有类内初始值
      4. 没有基类，也没有virtual类
   3. 聚合类初始值的顺序必须与声明的顺序一致

6. 字面值常量类

   1. constexpr函数的参数和返回值必须是字面值类型
   2. 除了算术类型，引用，指针，某些类也是字面类型
   3. 字面值类型的类可能含有constexpr函数成员
   4. 数据成员都是字面值类型的聚合类，是字面值常量类
   5. 如果一个类不是聚合类，符合下面要求的话，就是字面值常量类
      1. 数据成员都是字面值类型
      2. 类必须至少含有一个constexpr构造函数
      3. 如果有一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式
      4. 类必须使用析构函数的默认定义，该成员负责销毁类的对象
   6. constexpr构造函数

##### 类的静态成员

1. 有些成员与类本身相关，而与对象无关，这种用静态成员就比较好

2. 在成员声明之前加上static关键字，使其与类关联在一起

3. 静态成员可以是public或者private的

4. 类的静态成员存在于任何对象之外，对象不包含任何与静态数据成员有关的数据

5. 静态成员不能声明为const的

6. 静态成员函数内不能使用this

7. 使用作用域运算符直接访问静态成员：`double r; r = Account::rate();`

8. 虽然静态成员不属于任何对象，但是我们仍然可以通过类的对象，引用或者指针来访问静态成员，也就是下面这几种访问都是合法的

   ```c++
   Account ac1;
   Account *ac2 = &ac1;
   
   r = ac1.rate();
   r = ac2->rate(); //->等于*.
   ```

9. 成员函数不用类运算符就能直接使用静态成员

10. 定义静态成员

    1. 我们可以在类外定义静态成员（注意是定义不是声明，必须先在类内声明），但是定义时不要使用static关键字，因为这个关键字只能在类内出现

    2. 我们不能在类内初始化静态成员，必须在类外定义和初始化每个静态成员

    3. 每个静态数据成员只能定义一次

    4. 从类名开始，定义语句的剩余部分都位于类的作用域内，所以在定义静态成员的时候，可以直接使用成员函数，而不用多次加上类，示例：

       `double Account::interestRate = initRate();`这里直接使用这个成员函数，而不是写作`Account::initRate()`

11. 静态成员的类内初始化

    1. 通常情况下，静态成员不应该在类的内部初始化
    2. 我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr
    3. 

12. 静态成员应用的某些场景

    1. 静态成员和指针可以是不完全类型，但是其他成员不行

    2. 静态成员可以用作默认实参

       ```c++
       class Screen {
       public:
           Screen& clear(char = bkground);
           
       private:
           static const char bkground;
       }
       ```

       





### C++标准库

#### IO库

##### IO类

1. 3中流的类型，分别定义在3个独立的头文件中
   1. `iostream`头文件定义了：
      1. `istream, wistream`：从流读取数据
      2. `ostream, wostream`：向流写入数据
      3. `iostream, wiostream`：读写流
   2. `fstream`头文件定义了：
      1. `ifstream, wifstream`：从文件读取数据
      2. `ofstream, wofstream`
      3. `fstream, wfstream`
   3. `sstream`头文件定义了：
      1. `istringstream, wistringstream`：从string读写数据
      2. `ostringstream, wostringstream`：向string写入数据
      3. `stringstream, wstringstream`：读写string
2. 为了支持宽字符的语言，像cin等都有宽字符的版本，在前面加个w即可
3. 标准库使我们能够忽略不同类型的流之间的差异，这是通过**继承机制**实现的
4. 我们不能对IO对象进行拷贝或者赋值，所以函数中只能使用IO对象的引用，而且读写会改变IO对象的状态，所以引用不能是const的
5. IO对象可能发生错误，有些是可以回复的，但是有些不能
   1. IO条件状态
      1. `strm::iostate`：是一种机器相关的类型，提供了表达条件状态的完整功能
      2. `strm::badbit`用来指出流已经崩溃
      3. `strm::failbit`用来指出一个IO操作失败了
      4. `strm::eofbit`指出流已经到达了文件结束
      5. `strm::goodbit`指出流未处于错误状态，此值保证为0
      6. `s.eof()`若流的eofbit置位，则返回true
      7. `s.fail()`如果failbit或者badbit置位，返回true
      8. `s.bad()`如果badbit置位，返回true
      9. `s.good()`若处于有效状态，返回true
      10. `s.clear()`将所有条件状态位复位，将流的状态设置为有效，返回void
      11. `s.clear(flags)`根据flags，将流中对应条件状态位复位，flags的类型为1，返回void
      12. `s.setstate(flags)`与11一样，除了置位而不是复位
      13. `s.rdstate()`返回流当前条件状态，返回值类型为1
   2. 一个流如果发生错误，后续的所有IO操作都会失败，所以在使用一个流之前，要检查它是否处于一个良好状态，最简单的方法就是把它当成一个条件来使用
   3. 将流作为条件，只能告诉我们流是否有效，而无法告诉我们具体的事，我们可以通过1中的这些来了解详情
   4. IO库定义了4个iostate类型的constexpr值，这些值用来表示特定的位模式，可以与位操作符一起使用来一次性检测或者设置多个标志位
   5. `badbit`表示系统级错误，一般出现这个，流就无法使用了
   6. 发生可恢复错误后，`failbit`被置位，这种问题是可修正的，流可以继续使用
   7. 如果到达文件结束，`failbit和eofbit`都会被置位，`goodbit`为0，表示未发生错误
   8. `failbit,eofbit,badbit`中的任何一个被置位，检测流的标间都会是false
   9. clear成员是一个重载的成员
      1. 不接受参数的clear清除所有错误位
      2. 带参数的会将状态变成接受的参数那样
6. 管理**输出缓冲**
   1. 每个输出流都管理一个缓冲区，用来保存程序读写的数据
   
   2. 比如这行代码：`os << "please enter a value: "`，文本串有可能立即被打印出来，也有可能被操作系统保存在缓存区，随后再打印
   
   3. 有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作，可以带来很大的性能提升<font color='red'>这里有点奇怪，那就是C++程序和操作系统是什么关系？</font>
   
   4. 导致缓冲刷新的原因有很多
      
      1. 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行
      2. 缓冲区满时
      3. 可以使用操纵符，比如endl来显式刷新缓冲区
      4. 在每个输出操作之后，可以用操纵符`unitbuf`设置流的内部状态，来清空缓冲区。对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的
      5. 一个输出流可能被关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新，比如cin和cerr都关联到cout，所以读cin或者写cerr都会导致cout的缓冲区被刷新
      
   5. 刷新输出缓冲区
   
      1. 前面提到的`endl`会换行然后刷新缓冲区
      2. `flush`刷新缓冲区，不附加任何额外字符
      3. `ends`会加个空字符，刷新缓冲区
      4. `cout << "hi" << ends`
   
   6. 如果想让流在每次输出操作之后都刷新缓冲区，可以使用`unitbuf`操纵符，它告诉流在接下来的每次写操作之后都进行一个flush操作
   
      1. 示例
   
         ```c++
         cout << unitbuf;
         cout << nounitbuf;
         ```
   
      2. 可以使用`nounitbuf`操纵符重置流
   
   7. 关联流
   
      1. 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流
      2. 交互式的系统通常应该关联输入和输出流，这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来
      3. 关联使用tie成员函数：`cin.tie(&cout);`
      4. 输入流和输入流是不能关联的，也没有必要
      5. 输入流与输出流，或者输出流与输出流可以互相关联
      6. tie这个成员函数有两个版本
         1. 不带参数，有点像是查询函数，返回指向输出流的指针。如果未关联到流，返回空指针
         2. 接受一个指向ostream的指针，将自己关联到此ostream

##### 文件输入输出

1. 使用文件流对象
   1. 每个文件流类都定义了一个名为open的成员函数，可以完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或者写的模式
   2. 创建文件流对象时，如果传入文件名初始化，则open会被自动调用
   3. 在新C++标准中，文件名既可以是字符串，也可以是string对象
   4. 因为调用open可能会失败，所以open之后进行是否成功的检测通常是一个好习惯，检查就是`if (out)`也就是检查流是否可用
   5. 对一个已经打开的流使用open会失败，而且会让这个流不再可用。
   6. 当一个fstream对象被销毁的时候，close会自动被调用
2. 文件模式
   1. 列表
      1. in：以读的方式打开
      2. out：以写方式打开
      3. app：每次写操作前均定位到文件末尾
      4. ate：打开文件后立即定位到文件末尾
      5. trunc：截断文件
      6. binary：用二进制的方式进行IO
   2. 注意事项
      1. 读方式只能对ofstream或者fstream对象使用
      2. 只有在out使用时才可以设定trunc模式
      3. 只有trunc没被设定时，就可以设定app模式
      4. ate和binary模式可用于任何类型的文件流类型，且可以与其他文件模式组合使用
   3. 以out模式打开文件会丢弃已有数据，也就是写模式默认是从头开始写，会擦掉原本原件中的内容
      1. 默认情况下，因为ofstream默认以out模式打开，所以文件的内容会被丢弃。
      2. 阻止ofstream清空给定文件内容的方法是同时指定app模式，也就是从原本文件内容的末尾开始写
      3. `ofstream app2("file2", ofstream::out | ofstream::app);`
   4. 每次使用open函数都可以重新设定文件模式

##### string流

1. sstring头文件中定义了三个类型来支持内存IO，让string表现得像个IO流一样
   1. `istringstream`
   2. `ostringstream`
   3. `stringstream`
2. 这个头文件中定义的类型都是继承自前面的iostream头文件中的类型
3. `stringstream`有一些特有的操作
   1. `sstream strm`
   2. `sstream strm(s);`
   3. `strm.str()`
   4. `strm.str(s)`
4. 使用istringstream
   1. 







#### 顺序容器

##### 顺序容器概述

1. 顺序容器也就是提供位置信息来访问的
2. 标准库还提供了3中容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配
3. 标准库提供的顺序容器
   1. vector可变大小数组
      1. 支持快速随机访问
      2. 在尾部之外的位置插入或者删除元素可能很慢
   2. deque双端列表
      1. 支持快速随机访问
      2. 在头尾位置插入/删除速度很快
   3. list双向链表
      1. 只支持双向顺序访问
      2. 在任何位置插入/删除都很快
   4. forward_list单向列表
      1. 只支持单向顺序访问
      2. 在链表任何位置进行插入/删除操作都很快
   5. array固定大小数组
      1. 支持快速随机访问
      2. 不能添加或者删除元素
   6. string与vector相似的容器，但是专门用于保存字符
      1. 随机访问快
      2. 在尾部插入/删除很快
4. forward_list和array是新C++标准增加的类型
   1. array是比原生数组更加安全和容易使用的数组类型
   2. forward_list是设计用来达到与最好的手写的单向链表数据结构相当的性能
      1. 没有size操作，因为保存或者计算其大小就会比手写链表多出额外开销
   3. 新标准库的容器比旧版本快得多
5. 选择容器的基本原则：
   1. 除非有很好的理由选择其他容器，否则应该使用vector



##### 容器库概览

1. 一般来说，每个容器都定义在一个头文件中，文件名与类型名相同，即deque定义在头文件deque中

2. 没看懂

3. 迭代器

   1. 标准容器上的所有迭代器都支持我们访问容器的元素，而所有的这种操作都是通过解引用来实现的
   2. 标准库容器的所有迭代器都定义了递增运算符，从当前元素移动到下一个元素
   3. 迭代器范围
      1. 一个范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置
      2. 一对迭代器表示的内容范围是左闭合范围，也就是包含开头，不包含结尾
   4. 使用左闭合区间的编程假定，也就是好处
      1. 当begin=end的时候，范围为空
      2. 如果begin != end，则至少有一个元素，且begin指向其第一个元素

4. 容器类型成员

   1. 大多数容器还提供反向迭代器

   2. 容器里面还提供了很好用的类型别名，尤其当不知道容器内部元素类型的时候

      1. `iterator`：此容器类型的迭代器类型

      2. `const_iterator`

      3. `size_type`

      4. `difference_type`

      5. `value_type`

      6. `reference`

      7. `const_reference`

      8. 示例

         

5. 当不需要写访问的时候，应使用cbegin和cend来获得常量迭代器

6. 创建array时，除了指定元素类型，还要指定元素大小

7. 如果花括号初始化的值的数量少于array构造时传入的大小，剩下的值会默认初始化，不会报错，但是这里指的是初始化，在赋值的过程中如果这样，是会报错的

8. 容器之间的swap

   1. 相同类型的容器之间可以执行swap操作，比拷贝快得多，所以如果需要拷贝，部分情况可以使用swap来加快速度
   2. 赋值操作会导致左边容器内部的迭代器，引用和指针失效，而swap则不会，这是另一个其比赋值好的地方
   3. 上面两个优点的原因是：swap并未将元素本身交换，只是交换了2个容器的内部数据结构，而因为未交换元素本身，指向元素的指针，迭代器之类的也就不会失效
   4. 但是上面说道的这些对于array都无用，因为对array使用swap，会真正交换它们的元素
   5. `swap(a1, a2);`或者`c1.swap(c2);`

9. 赋值assign

   1. 赋值操作要求两边的运算对象类型相同，将右边对象的所有元素拷贝到左边的运算对象中所有元素拷贝到左边运算对象中。

   2. 赋值操作并不需要容器类型相同，所以可以实现不同容器之间的赋值，但是一定要保证运算对象之间的类型相同

   3. 示例

      ```c++
      list<string> names;
      vector<const char*> oldstyle;
      names = oldstyle; //错误，因为两个是不同类型，不能进行赋值操作
      
      name.assign(oldstyle.cbegin(), oldstyle.cend()); //正确，因为运算对象的类型相同
      ```

10. 新标准库还提供了非成员版本的swap，这在泛型变成中是非常重要的，同意使用非成员版本的swap是一个好习惯

11. 每个容器类型（除了forward_list）都支持3个与大小相关的操作

    1. size：成员函数，返回容器中元素的数目
    2. empty：
    3. max_size：返回一个大于或等于该类型所能容纳的最大元素数的值
    4. forward_list不支持size函数

12. 关系运算符

    1. 每个容器类型都支持相等运算符：== !=
    2. 除了无序容器，其他所有容器都支持关系运算符：> >= < <=
    3. 比较容器其实就是对容器中的元素进行挨个依次比较

##### 顺序容器操作

1. 除了array，其他标准容器都提供了灵活的内存管理，也就是可以动态改变容器的大小

2. 向顺序容器中添加元素的操作：

   1. `c.push_back(t)`在c的尾部创建一个元素

      1. 返回void。
      2. forward_list不支持，但是string支持，要越来越把string当成一种只装字符的容器

   2. `c.emplace_back(args)`

   3. `c.push_front(t)`

      1. 这是只有`list, forward_list, deque`这些容器支持的操作
      2. 

   4. `c.emplace_front(args)`

   5. `c.insert(p, t)`

      1. p是迭代器

      2. 因为p是迭代器，迭代器可以指向尾后元素，所以实际上将新元素插入到p前面

      3. 所有的insert操作都会返回指向新添加的第一个元素的迭代器，很有用，因为可以用这个机制不断地向容器的最前面添加元素

         ```c++
         list<string> lst;
         auto iter = lst.begin();
         
         while (cin >> word)
             iter = lst.insert(iter, word); //等价于一直调用push_front
         ```

   6. `c.emplace(p, args)`

   7. `c.insert(p, n, t)`

   8. `c.insert(p, b, e)`把b和e指定范围内的元素插入到p之前

   9. `c.insert(p, il)`将给定值il插入到迭代器p之前

      1. il是一个花括号包围的元素值列表

   10. `emplace`等三个成员函数是新标准新添加的，表示构造而不是拷贝元素

       1. `emplace_font, emplace, emplace_back`分别对应`push_front, insert, push_back`

       2. 不同之处在于，正常的那些函数是拷贝对象到容器中，而前者是将参数传递给元素类型的构造函数，使用这些参数在容器管理的内存中直接构造函数

       3. 我觉得差别有点像是emplace这些函数可以隐式转换，也就是可以传入参数，然后自动初始化为对象然后插入，而老方法只能传入初始化好的对象：

          ```c++
          c.emplace_back("12345", 25, 15.99); //正确，在容器c末尾加入一个Sales_item对象
          c.push_back("12345", 25, 15.99); //错误，因为这个操作被看做一次性添加3个对象，是不合法的
          c.push_back(Sales_item("12345", 25, 15.99)); //正确，与第一行使用emplace函数等价
          ```

       4. emplace等函数的参数必须与元素类型的构造函数相匹配

3. 访问元素

   1. 所有顺序容器都有`front`成员函数，返回首元素的引用
   2. 除`forward_list`外所有顺序容器都有`back`成员函数，返回尾元素的引用
   3. `c[n]`返回下标为n的元素的引用
      1. 下标越界时不会有提醒，要注意
      2. 还有at都只适用于`string, vector, deque, array`
   4. `c.at(n)`返回下标为n的元素的引用
      1. 如果下标越界，抛出out of range异常，比使用下标安全

4. 删除元素

   1. 使用`erase`成员函数
      1. 可以接受一个迭代器参数，删除指定元素
      2. 也可以接受2个迭代器参数，删除这个范围内的所有元素
   2. `clear`成员函数，删除所有元素

5. 特殊的`forward_list`操作

   1. 因为单向链表无法访问前面的元素，所以并没有定义其他顺序容器有的`insert, emplace, erase`等函数，而是定义了：
      1. `insert_after`
      2. `emplace_after`
      3. `erase_after`
   
6. 改变容器大小

   1. 通过resize成员函数来改变容器大小
   2. 还可以接受2个参数：n和t，任何新添加的元素都初始化为t

7. 容器操作可能使迭代器失效

   1. 向容器中添加或者删除容器可能会使指向容器元素的指针引用或迭代器失效。（也就是说改变元素不会）

   2. 使用失效的迭代器和使用未定义的指针一样，是严重的错误

   3. 向容器添加元素后

      1. 如果是list和forward_list这种链表，迭代器仍然有效
      2. 对于deque
         1. 插入到首尾之外的任何位置都会导致迭代器，指针和引用失效。
         2. 如果在首尾添加元素，迭代器会失效，但是指向存在元素的引用和指针不会
      3. 对于vector和string，分两种情况
         1. 存储空间重新分配：迭代器，指针，引用都会失效
         2. 存储空间未重新分配：指向插入位置之前的元素的都不会失效，但是之后的都会失效

   4. 向容器删除元素后

      1. 当我们删除元素后，所有的容器的尾后迭代器都会失效
      2. 对于deque
         1. 在首尾之外任何地方删除元素，指向被删除元素之外的任何东西都会失效
         2. 删除首尾元素，不受影响
      3. 对于vector和string，被删除元素之前的元素都不受影响

   5. 使用迭代器时，最小化要求迭代器必须保有的程序片段是个好方法

   6. 每次操作容器之后都重新定位迭代器

   7. 编写改变容器的循环程序

      1. 使用insert或者erase函数的话，还是很容易，因为会返回迭代器

      2. 示例

         ```c++
         vector<int> vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
         auto iter = vi.begin();
         
         while (iter != vi.end()){
             if (*iter % 2){
                 iter = vi.insert(iter, *iter);
                 iter += 2;
             } else{
                 iter = vi.erase(iter);
             }
         }
         ```

   8. 不要保存end返回的迭代器，因为尾后迭代器经常失效

##### vector对象是如何增长的

1. 因为如果简单地将其作为对象装进内存，一旦需要增加元素，就需要执行一次内存的分配和释放操作，性能会很慢
2. 所以通常会预留一些空间，这样就不需要每次添加新元素都需要重新分配内存空间了
3. 管理容量的成员函数
   1. `c.shrink_to_fit()`
      1. 只适用于vector,string和deque
      2. 将capacity减少到与size相同大小
   2. `c.capacity()`
      1. 不重新分配内存的画，c可以保存多少元素
   3. `c.reserve(n)`
      1. 分配至少能容纳n个元素的内存空间

##### 额外的string操作

1. 构造string的其他方法
   1. `string s(cp, n)`：s是cp指向的数组的前n个字符的拷贝，这个数组应该至少包含n个字符
   2. `string s(s2, pos2)`：s是string s2从下标pos2开始的字符的拷贝，pos2要小于s2的长度
   3. `string s(s2, pos2, len2)`
2. substr操作
   1. `s.substr(pos, n)`返回一个string，包含s中从Pos开始n个字符的拷贝，pos默认值为0，n的默认值为s.size()-pos
3. 改变string的其他方法
4. string的搜索操作
5. 数值转换

##### 容器适配器

1. 适配器是标准库中的一个通用概念，容器，迭代器和函数都有适配器。
2. 适配器是一种机制，能够让某种事物的行为看起来像另外一种事物一样
3. 所有容器适配器都支持的操作和类型，其实就是容器都支持的，有点像Python中的duck type
   1. `size_type`
   2. `value_type`
   3. `container_type`
   4. `A a;`
   5. `A a(c);`
   6. 关系运算符
   7. `a.empty()`
   8. `a.size()`
   9. `swap(a, b);`
   10. `a.swap(b)`
4. 定义一个适配器
   1. 每种适配器都要定义2个构造函数
      1. 默认构造函数：创建一个空对象
      2. 接受一个容器的构造函数：拷贝该容器来初始化适配器
   2. 所有的适配器都要求容器具有添加或者删除的能力，所以不能使用在array上面
      1. 同理，适配器都要求容器具有添加，删除和访问尾元素的能力，所以forward_lsit也不能使用
   3. stack适配器要求有push_back, pop_back和back操作，所以除了array和forward_list都可以使用
   4. queue适配器要求push_back, front和push_front，所以只能构造在list和deque之上（不能在vector上）
5. 栈适配器
   1. stack定义在头文件stack中
   2. stack除了3中通用的之外，还支持的操作：
      1. `s.pop()`
      2. `s.push(item)`
      3. `s.emplace(args)`
      4. `s.top()`
6. 队列适配器
   1. 感觉没啥新鲜的



#### 泛型算法

##### 概述

1. 顺序容器只定义了很少的操作，如果想要做其他操作，标准库并没有提供，而是定义了一组泛型算法。之所以这些算法叫做泛型是因为它们可以用于不同类型的元素和多种容器类型，或者其他类型的序列
2. 大部分算法都定义在头文件algorithm中，标准库还在头文件numeric中定义了一组数值泛型算法
3. 一般情况来说，这些算法不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作，因为这样的话，所有的带有迭代器的类型都可以使用这个方法
4. 迭代器让算法不依赖于容器，但算法依赖于元素类型的操作
5. 算法可能会改变容器中保存的值，也可能在容器内移动元素，但永远不会直接添加或者删除元素，因为这样的话，迭代器就失效了

##### 初识泛型算法

1. 除了少数个例之外，标准库算法都对一个范围内的元素进行操作，我们将此元素范围称为输入范围。一般是传入要处理的第一个元素和尾元素之后的迭代器

2. 只读算法

   1. `find`
   2. `count`
   3. `accumulate`，定义在头文件`numeric`中。接受的第三个参数是和的初值，它同时还决定了使用哪个加法以及返回值的类型
      1. `int sum = accumulate(vec.cbegin(), vec.cend(), 0);`这种就是把vector的元素加起来
      2. `string sum = accumulate(vec.cbegin(), vec.cend(), string(""));`这种是将vector中的字符连接起来
   4. 对于只读算法，最好使用cbegin和cend
   5. `equal`，用于确认两个序列是否保有相同的值，接受第3个参数为第二个序列的首元素
      1. 我们可以使用这个函数来比较不同类型的容器中的值是否相同

3. 写容器元素的算法

   1. 记住算法不会执行容器操作，因此它们自身不可能改变容器的大小

   2. `fill`，接受一对迭代器，还接受一个值为第三个参数，fill将给定的这个值赋予输入序列的每个元素

   3. `fill_n`，接受一个迭代器，一个计数值和一个值，也就是将从迭代器开始的n的元素都设置为第三个值

   4. 算法不检查写操作，所以说像`fill_n`的操作有可能很危险如果n大于容器的大小

   5. 为了解决上面的危险，可以使用插入迭代器

      1. 插入迭代器是一种向容器添加元素的迭代器。通常使用迭代器改变元素时，是改变迭代器指向的元素，但是插入迭代器是拷贝值后添加到容器中

      2. `back_inserter`，定义在头文件`iterator`中

      3. `back_inserter`接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器，当通过此迭代器赋值时，赋值运算符会调用`push_back`将值插入到容器中

         下面的代码是将42插入到空的vector中

         ```c++
         vector<int> vec;
         auto it = back_inserter(vec);
         *it = 42;
         ```

         还能用这个特性来实现一些意向不到的功能

         ```
         vector<int> vec;
         
         fill_n(back_inserter(vec), 10, 0);
         ```

   6. 拷贝算法

      1. 向另一个目的位置迭代器指向的输出序列中的元素写入数据

      2. 接受三个迭代器，前两个表示要被拷贝的范围，第三个表示拷贝开始的地方

         ```c++
         int a1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
         int a2[sizeof(a1)/sizeof(*a1)];
         
         auto ret = copy(begin(a1), end(a1), a2);
         ```

      3. 返回的是其目的位置迭代器的值，即ret恰好指向拷贝到a2的尾元素之后的值

      4. 多个算法都提供了拷贝版本，也就是不改变原来序列的值，而是新建一个对象，将改变后的值拷贝进去

4. 重排容器的元素

   1. sort是一个典型的这类算法

      1. 实现排序并删除重复出现的文本功能：

         ```c++
         void elimDups(vector<string> &words){
             sort(words.begin, words.end());
             
             auto end_unique = unique(words.begin(), words.end());
             words.erase(end_unique, words.end());
         }
         ```

      2. 首先使用sort函数来排序，让重复的单词排在一起。

      3. 然后使用unique函数来重新排列，让不重复的元素出现在vector的开始部分，返回指向这个开始部分后的指针

      4. 这两个函数都是只改变顺序，因为算法不适用容器操作来增添元素

      5. 最后一个是容器操作，用来真正删除元素，传入两个迭代器

      6. 就算words中没有重复单词，也就是传入erase的是两个相同的迭代器，也是安全的

##### 定制操作

1. 向算法传递函数

   1. 谓词

      1. 谓词是一个可调用的表达式

      2. 标准库用的有一元谓词和二元谓词两种

      3. 元素类型必须能转换为谓词的参数类型

      4. 使用实例

         ```c++
         bool isShorter(const string &s1, const string &s2){
             return s1.size() < s2.size();
         }
         
         sort(words.begin(), words.end(), isShorter);
         ```

2. lambda表达式

   1. 有时我们希望有更多参数，而且也不想专门为每一个都编写一个独立的谓词，这时就可以使用lambda表达式
   2. 可调用对象
      1. 函数
      2. 函数指针
      3. 重载了函数调用运算符的类
      4. lambda表达式
   3. 一个lambda表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数
   4. lambda函数有一个返回类型，一个参数列表和一个函数体，但是lambda可以定义在函数内部，而普通函数则不行
   5. lambda定义形式：`[capture list] (parameter list) -> return type {function body}`
      1. capture list是一个lambda所在函数中定义的局部变量的列表
   6. 我们可以略过参数列表和返回类型，但是必须包含capture list和函数体：`auto f = [] {return 42;};`
   7. 在定义后，就可以和使用普通函数一样调用：`cout << f() << endl;`
   8. lambda表达式不能有默认参数
   9. 没有使用外部函数局部变量时的使用示例：`stable_sort(words.begin(), words.end(), [](const string &a, const string &b){return a.size() < b.size();});`
   10. lambda不能使用所在函数内的局部变量，如果要使用，要在方括号中捕获，但是所在函数之外的变量，lambda是可以使用的，比如cout这种的
   11. 可以看到，定义lambda并不需要lambda这个关键字

3. lambda的捕获和返回

   1. 当定义一个lambda时，编译器生成一个与lambda对应的新的类类型

   2. 类似于普通函数，lambda的捕获方式也分成值传递和引用传递，采用值传递的前提是该对象可以拷贝（像流之类的就不行）

   3. 与参数不同，被捕获的变量是在lambda创建时拷贝，而不是调用时拷贝，这就会造成如果使用值传递，那么在lambda函数出事后，该值的值改变时，不会影响到lambda函数内部的该值：

      ```c++
      void fcn1(){
          size_t v1 = 42;
          
          auto f = [v1] {return v1;};
          
          v1 = 0;
          
          auto j = f();
      }
      ```

      这里仍然会返回42而不是0，原因上面说了

   4. 3中的情况，如果使用引用传递的话，就不会发生了

   5. 引用捕获也有限制，那就是必须保证在定义之前，要存在，而且因为函数中定义的局部变量在函数完成后会销毁，所以如果要在函数之后再使用，比如说要被返回，就不能用引用传递

   6. 隐式捕获：我们还可以让编译器自己通过函数体内的代码推测出我们要捕获哪些变量，只要在方括号中使用=和&即可

      1. =表示采用值捕获
      2. &表示采用引用捕获

   7. 还可以混合使用隐式捕获和显式捕获，因为有时我们希望有些值使用引用传递，有些值使用值传递，使用时要注意：

      1. 捕获列表的第一个一定是=或者&，然后再是显式捕获
      2. 显式和隐式的传递方法必须不一样

   8. 可变lambda

      1. 如果想要让lambda函数改变值引用的捕获的变量，就必须在参数列表首加上关键字mutable
      2. 但是如果局部变量带了const，就算lambda加上了mutable也不能改变

   9. 指定lambda返回类型

      1. 当我们需要为lambda定义返回类型时，必须使用尾置返回类型：

         ```c++
         transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int
                   {if (i < 0) return -i;
                   else return i;});
         ```

4. 参数绑定

   1. 对于捕获局部变量的lambda，用函数很难替换他，比如在find_if中，接受的参数必须是一元谓词，也就是说只能接受一个参数，这时函数就很难办
   2. 可以用定义在头文件`functional`中的名为bind的标准库函数来解决这个问题。
   3. `bind`可以看做是一个通用的函数适配器，它接受一个可调用的对象，生成一个新的可调用对象来适应元对象的参数列表
   4. 调用`bind`的一般形式为：`auto newCallable = bind(callable, arg_list);`
   5. `arg_list`可以包含形如`_n`的名字，这中名字是占位符，表示`newCallable`的参数
   6. 示例：`auto check6 = bind(check_size, _1, 6);`
      1. 这里只用了一个`_1`，表示生成的check6只接受一个参数
   7. 名字`_n`都定义在名为`placeholders`的命名空间里，而这个命名空间又定义在`std`中
   8. `placeholders`命名空间也定义在头文件`functional`中
   9. 像这样定义：`auto g = bind(f, a, b, _2, c, _1);`
      1. 说明f有5个参数
      2. 说明g有2个参数
      3. 而且g的第一个参数会作为f的第5个，g的第二个会作为f的第3个参数
   10. 还可以使用`bind`来调换参数顺序：将`sort`中的第3个参数从`isSorter`变成`bind(isShorter, _2, _1)`就可以实现调换顺序
   11. bind默认是值传递，有时我们也需要引用传递，比如对于流对象这种不能拷贝的，我们就可以使用标准库中的`ref`函数
   12. `ref`函数返回一个对象，包含给定的引用，是可以拷贝的
   13. 标准库中还有一个`cref`，返回的是const 引用
   14. ref和cred都是定义在头文件`functional`中

##### 再探迭代器

1. 除了前面用的迭代器，标准库在头文件`iterator`中还额外定义了几种迭代器

   1. 插入迭代器：绑定在一个容器上，可用来向容器插入元素
   2. 流迭代器：绑定在流上，可用来遍历关联的IO流
   3. 反向迭代器：它们向后实际上是向前移动，但是forward_list没有这种迭代器
   4. 移动迭代器：专门用来移动元素

2. 插入迭代器

   1. 支持的操作：
      1. `it = t`在it指定的位置插入值t
      2. `*it, ++it, it++`：这些操作虽然存在，但是不会对it做任何事，都只是返回it
   2. 有3中类型
      1. `back_inserter`
      2. `front_inserter`
      3. `inserter`

3. 流迭代器

   1. 有几种

      1. `istream_iterator`
      2. `ostream_iterator`

   2. `istream_iterator`操作

      1. 流迭代器使用>>来读取流，所以流迭代器要读取的类型必须定义了输入运算符

      2. 可以通过默认初始化流迭代器来得到一个'尾后迭代器'

      3. 下面是利用流迭代器将输入放入vector的例子：

         ```c++
         istream_iterator<int> in_iter(cin);
         istream_iterator<int> eof;
         
         while(in_iter != eof){
             vec.push_back(*in_iter++);
         }
         ```

         1. 这里使用了`in_iter != eof`，对于一个绑定到流的流迭代器，当其绑定的流遇到文件尾或者IO错误，就会和尾后迭代器相等

         2. 可以这样来改写上面的代码：

            ```c++
            istream_iterator<int> in_iter(cin), eof;
            vector<int> vec(in_iter, eof);
            ```

      4. 使用算法操作流迭代器

         1. 可以利用流迭代器在算法中：使用`accumulate`来计算输入的和：

            ```c++
            istream_iterator<int> in(cin), eof;
            cout << accumulate(in, eof, 0) << endl;
            ```

      5. 允许懒惰求值，当迭代器绑定到流中，并不会马上开始读取数据，知道我们真正开始读取流迭代器的时候才会读取流的数据，这样在很多情况下可以提升性能

   3. `ostream_iterator`操作

      1. `ostream_iterator`必须绑定到一个指定的流，像前面的空的是不被允许的

      2. 它支持的操作与前面的输入流迭代器基本相同，除了不支持默认初始化，加了一个初始化函数：
         
         1. `ostream_iterator<T> out(os, d);`：将类型为T的值写入到输入流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组（也就是C风格字符串）
         
      3. 通过ostream_iterator来输出值的序列

         ```c++
         ostream_iterator<int> out_iter(cout, " ");
         for (auto e : vec)
             *out_iter++ = e;
         cout << endl;
         ```

      4. 3中的解引用和递增符号其实是可以忽略的，变成：`out_iter = e;`，因为这些操作实际上对于流迭代器没有任何用

      5. 还可以通过调用`copy`来打印vec中的操作：`copy(vec.begin(), vec.end(), out_iter);`，这里也是终于知道为什么copy要这样设计了，因为至少流就可以用了

4. 反向迭代器

   1. 可以通过`rbegin, rend, crbegin, crend`等成员函数来获得反向迭代器
   2. 

5. 移动迭代器

##### 泛型算法结构

1. 每个算法都要求接受的迭代器能实现一定的功能，根据能实现的功能分成一下5类，每个算法都会对它的每个迭代器参数指定下面的类别
   1. 输入迭代器：只读，不写；单遍扫描，只能递增
   2. 输出迭代器：只写，不读；单边扫描，只能递增
   3. 前向迭代器：可读写；多遍扫描，只能递增
   4. 双向迭代器：可读写；多遍扫面，可递增递减
   5. 随机访问迭代器：可读写；多遍扫描，支持全部迭代器运算
2. 一个高层级别的迭代器支持底层类别迭代器的所有操作
3. 算法形参模式
   1. 四种形式之一
      1. `alg(beg, end, other args);`
      2. `alg(beg, end, dest, other args);`
      3. `alg(beg, end, beg2, other args);`
      4. `alg(beg, end, beg2, end2, other args);`
4. 算法命名规范
   1. 一些算法使用重载形式传递一个谓词
   2. `_if`版本的算法
      1. 接受一个元素值的算法通常有另一个不同名的版本，接受一个谓词代替元素值，接受谓词参数的算法那都有附加的`_if`后缀
   3. 区分拷贝元素的版本和不拷贝的版本
      1. 一般来说重排元素的算法会将重排后的元素写回给定的输入序列中，但是它们还有另外一个版本，那就是将元素写到一个指定的输出目的位置
      2. 这类算法都会有`_copy`后缀
      3. 一些算法同事提供`_if`和`_copy`版本，可以组合使用

##### 特定容器算法

1. 与其他容器不同，list和forward_list这两个链表容器定义了几个成员函数形式的算法。
   1. `lst.merge(lst2)`
   2. `lst.merge(lst2, comp)`
   3. `lst.remove(val)`
   4. `lst.remove_if(pred)`
   5. `lst.reverse()`
2. 它们定义了独有的`sort, merge, remove, reverse和unique`
3. 其他类型的算法也可以用在链表上，但是代价太高了，因为这些算法需要交换元素，但是链表可以通过交换元素之间的连接而不是真的交换值来实现交换元素，所以链表版本的算法性能比通用的好很多
4. 链表类型还定义了splice算法，这是链表数据结构所特有的
   1. 
5. 链表特有的算法会改变容器







#### 关联容器

##### 使用关联容器

1. 关联容器支持高效的关键字查找和访问
2. 有2个主要的关联容器，分别是
   1. map
   2. set
3. 标准库提供了8种关联容器
   1. 有序集合
      1. `map`
      2. `set`
      3. `multimap`
      4. `multiset`
   2. 无序集合
      1. `unordered_map`
      2. `unordered_set`
      3. `unordered_multimap`
      4. `unordered_multiset`
4. map和multimap定义在头文件map中；set和multiset定义在头文件set中
5. 类似顺序容器，关联容器也是模板
6. 当从map中提取一个元素时，会得到一个pair类型的对象。这种对象有first和second两个成员保存关键字和关键值

##### 关联容器概述

1. 关联容器不支持顺序容器的位置相关的操作

2. 关联容器也不支持构造函数或者插入操作这些接受一个元素值和一个数量值的操作

3. set是关键字的集合，而不是关键值的集合

4. 一个map和set的关键字一定要是唯一的，但是multimap和multiset没有这个限制

5. 对于有序的关联容器，，需要定义比较元素的方法。默认情况下，使用<来比较两个关键字。

6. 我们可以传入我们自定义的比较元素的方法，但是这个操作必须要在关键字类型上定义一个严格弱序，也就是有下面的性质：

7. 为了指定使用自定义的操作，在定义关联容器时必须提供2个类型：关键字类型和比较操作类型（一种函数指针类型）

   ```c++
   bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs){
       return lhs.isbn() < rhs.isbn();
   }
   
   multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
   ```

   1. 方括号中的第二个参数是比较操作类型
   2. 使用`decltype`来制定出自定义操作的类型，但是当用这个来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针
   3. 后面括号里面的意思是用`compareIsbn来初始化bookstore对象`，也就是向bookstore添加元素时，通过调用compreIsbn来为这些元素排序
   4. 可以直接用`compareIsbn而不是&compareIsbn`，因为当我们使用一个函数的名字时，它会自动转化为一个指针

8. pair类型

   1. 这是一个标准库类型，定义在头文件`utility`中
   2. 可以默认初始化，也可以为每个成员提供初始化器：`pair<string, string> author{"James", "joyce"};`
   3. pair的数据成员是公开的，可以用成员访问符号类直接访问

##### 关联容器操作

1. 类型

   1. `key_value`：关键字类型
   2. `mapped_type`：关键值类型，只在`map`中存在
   3. `value_type`：在set中和`key_value`一样，但是在map中是pair

2. 一个map的`value_type`是一个pair，但是其中的关键字是const

3. 虽然set类型同事定义了iterator和const_iterator，但是两者都只允许访问set中的元素

   ```c++
   set<int> iset = {0, 1, 2, 3, 4};
   set<int>::itterator set_it = iset.begin();
   if (set_it != iset.end()){
   	*set_it = 42;
   	cout << * set_it << endl;
       set_it++;
   }
   ```

4. 遍历关联容器

   1. 用迭代器就行，和上面代码块里的一样

5. 关联容器和算法

   1. 我们通常不对关联容器使用泛型算法，因为关键字是const，所以我们不能把关联容器传递给修改或者重排的算法
   2. 关联容器可以使用搜索的算法，但是它的结构会比那些算法更快
   3. 所以使用关联容器专用的算法比使用泛型的算法快很多

6. 添加元素

   1. 因为set和map不能有相同的关键字，所以往容器添加已经存在的元素对容器没有影响
   2. set使用insert方法，有2个版本
      1. 接受一对迭代器
      2. 接受一个初始化器列表
   3. 两种insert方法的行为类似对应的构造函数，因为关联容器的顺序是它自己定的，所以我们只需要将元素插进去即可，无法指定插入位置
   4. map添加元素
      1. 有4种方法：
         1. `word_count.insert({word, 1});`
         2. `word_count.insert(make_pair(word, 1));`
         3. `word_count.insert(pair<string, size_t>(word, 1));`
         4. `word_count.insert(map<string, size_t>::value_type(word, 1));`
   5. 关联容器还都支持emplace方法
   6. insert方法返回一个pair对象
      1. first成员为指向具有给定关键字的元素的迭代器
      2. second成员为bool值，指出元素是否插入成功，还是已经存在于容器中
   7. 向multimap或者multiset添加元素
      1. insert方法因为总是成功，所以只返回指向新元素的迭代器

7. 删除元素

   1. 使用erase方法，有3个版本
      1. `c.erase(k)`删除关键字为k的元素
      2. `c.erase(p)`删除迭代器p所指向的元素
      3. `c.erase(b, e)`删除迭代器b和e这个范围之间的元素
   2. 对于map和set，erase方法返回0或者1，返回0表示想要删除的元素不在容器中
   3. 对于multimap和multiset，返回的值可能会大于1，因为一个关键字可能会对应多个元素

8. map的下标操作

   1. map和unordered_map都提供了下标运算符和一个at方法
   2. multimap和unordered_multimap不能进行下标操作，因为一个关键字对应多个关键值

9. 访问元素

   1. 查找元素的操作

      1. `c.find(k)`返回一个迭代器，如果不在容器中，返回尾后迭代器
      2. `c.count(k)`返回k的数量
      3. `c.lower_bound(k)`返回一个迭代器，指向第一个关键字不小于k的元素
      4. `c.upper_bound(k)`
      5. `c.equal_range(k)`返回一个迭代器pair，表示关键字等于k的元素范围，如果k不存在，Pair两个成员均等于c.end()

   2. 尽量使用find而不是下标，因为下标有个很严重的副作用，那就是如果不存在，会插入一个该元素

   3. 遍历multimap

      1. 对于multimap这种允许多个关键字同时存在的关联容器，可以用下面的方法来遍历，利用它们会相邻存储的特点：

      ```c++
      string search_item("Alan de Botton");
      auto entries = authors.count(search_item);
      auto iter = authors.find(search_item);
      
      while (entries){
          cout << iter->second << end;
          ++iter;
          --entries;
      }
      ```

      2. 除了上面的方法，还可以使用`lower_bound, upper_bound`来解决遍历的问题：

      ```c++
      for (auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg){
          cout << beg->second << endl;
      }
      ```

      3. 还可以使用equal_range函数来解决遍历问题

         ```c++
         for (auto po = authors.equal_range(search_item); pos.first != pos.second; ++pos.first){
             cout << pos.first->second << endl;
         }
         ```

         其实和2中也很像，就是将他们封装进了一个pair对象

10. 一个单词转换的map

    1. 这里是一个现实中使用关联容器的例子
    2. 首先

    ```c++
    //定义word_transform函数
    void word_transform(ifstream &map_file, ifstream &input){
        auto trans_map = buildMap(map_file);
        string text;
        while (getline(input, text)){
            istringstream stream(text);
            string word;
            bool firstword = true;
            while (stream >> word){
                if (firstword)
                    firstword = false;
                else
                    cout << " ";
                
                cout << transform(word, trans_map);
            }
            cout << endl;
        }
    }
    
    //建立转换映射
    map<string, string> buildMap(ifstream &map_file){
        map<string, string> trans_map;
        string key;
        string value;
        
        while (map_file >> key && getline(map_file, value))
            if (value.size() > 1)
                trans_map[key] = value.substr(1);
        	else
                throw runtime_error("no rule for " + key);
        return trans_map;
    }
    
    //生成转换文本
    const string& transform(const string &s, const map<string, string> &m){
        auto map_it = m.find(s);
        
        if (map_it != m.cend())
            return map_it->second;
        else
            return s;
    }
    ```

##### 无序容器

1. 前面的关联容器使用比较运算符来组织元素，无序容器是使用哈希函数和关键字类型的==运算符
2. 适合使用无序容器的场景
   1. 关键字类型的元素没有明显的序关系
   2. 维护元素的序代价非常高昂时
3. 使用无序容器
   
   1. 除了哈希管理操作，无序容器提供了和有序容器一样的操作
4. 管理桶
   1. 无序容器在存储上组织为一组桶，每个桶保存0个或多个元素
   2. 使用哈希函数将元素映射到桶
   3. 访问一个元素的过程：先计算元素的哈希值，指出应该搜索的桶，然后在指定的桶中搜索
   4. 因为相同的元素哈希值也相同，所以相同的元素在同一个桶中
   5. 无序容器的性能依赖于哈希函数的质量和桶的数量和大小
   6. 无序容器提供了管理桶的函数
      1. 桶接口
         1. `c.bucket_count()`查看正在使用的桶的数量
         2. `c.max_bucket_count()`能容纳的最多的桶的数量
         3. `c.bucket_size(n)`第n个桶中有多少个元素
         4. `c.bucket(k)`关键字为k的元素在哪个桶中
      2. 桶迭代
         1. `local_iterator`可以用来访问桶中元素的迭代器
         2. `const_local_iterator`
         3. `c.begin(n), c.end(n)`桶n的首元素和尾后迭代器
         4. `c.cbegin(n), c.cend(n)`
      3. 哈希策略
         1. `c.load_factor()`每个桶的平均元素数量，返回float值
         2. `c.max_load_factor()`
         3. `c.rehash(n)`重组存储，使得bucket_count>=n，而且bucket_count>size/max_load_factor
         4. `c.reverse(n)`重组存储，使得c可以保存n个元素且不用rehash
5. 无序容器对于关键字类型的要求
   
   1. 默认情况下，使用关键字类型的==来比较元素
   
   2. 还使用一个`hash<key_type>`类型的对象来生成每个元素的哈希值
   
   3. 标准库为内置类型提供了hash模板，还为一些标准库类型也提供了，所以我们可以直接定义关键字是内置类型，string，智能指针类型的无序容器
   
   4. 对于我们自己定义的对象，后面会介绍如何定义自己的hash模板
   
   5. 为了能够在无序容器中使用我们自己定义的对象，我们可以这样做：
   
      ```c++
      size_t hasher(const Sales_data &sd){
          return hash<string>()(sd.isbn());
      }
      
      bool eqOp(const Sales_data &lhs, const Sales_data &rhs){
          return lhs.isbn() == rhs.isbn();
      }
      
      using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;
      SD_multiset bookstore(42, hasher, eqOp);
      ```
   
      1. 可以看到这里使用了别名来简化声明
   
      2. 完整的无序容器的定义中，尖括号包括元素类型，哈希操作类型，比较操作类型
   
      3. 如果我们的类定义了==运算符，则可以只重载哈希函数：
   
         `unordered_set<Foo, decltype(FooHash)*> fooSet(10, FooHash);`



#### 动态内存

##### 动态内存与智能指针

1. 目前为止只使用过两种
   1. 静态内存：用来保存
      1. 局部static对象
      2. 类static数据成员
      3. 定义在任何函数之外的变量
   2. 栈内存：用来保存
      1. 定义在函数内的非static对象
   
2. 分配在前面2中内存中的对象由编译器自动创建和销毁。
   1. 栈对象，在其定义的程序快运行的时候存在
   2. static对象，在使用之前分配，程序结束时销毁
   
3. 除了上面2中，还有一种叫做**自由空间**或者说**堆**。用来储存动态分配的对象，也就是在程序运行时分配的对象。

4. 堆中对象的生存期由程序自己控制，也就是说，当动态对象不再使用时，要用代码显式地销毁它们

5. 动态内存的管理是由一对运算符完成的
   1. new：在动态内存中为对象分配空间，并返回一个指向该对象的指针
   2. delete：接受一个动态对象的指针，销毁该对象，并且释放与之关联的内存
   
6. 为了更容易地使用动态内存，新的标准库提供了2中智能指针来管理动态对象

7. 这2种智能指针与普通指针的区别在于它们会自动释放所指向的对象。

8. 这2中智能指针互相之间的区别在于管理底层指针的方法
   1. `shared_ptr`允许多个指针指向同一个对象
   2. `unique_ptr`独占所指向的对象
   
9. 除了这两种智能指针，标准库还定义了一种叫做`weak_ptr`的伴随类，它是一种弱引用，指向`shared_ptr`所管理的对象，这三中类型都定义在头文件`memory`中

10. `share_ptr`类
    1. 它也是模板，因此要额外提供信息，也就是指针可以指向的类型
    2. `shared_ptr<list<int>> pt2;`
    3. 默认初始化的智能指针中保存着一个空指针
    
11. 智能指针的操作和普通指针非常像，也可以使用解引用之类的操作

12. 两种智能指针都支持的操作
    1. `shared_ptr<T> sp`：空智能指针，可以指向类型为T的对象
    2. `unique_ptr<T> up`
    3. `p`：将p用作一个条件判断，若指向一个对象则为true
    4. `*p`：解引用p，获得他只想的对象
    5. `p->men`：等价于`(*p).men`
    6. `p.get()`：返回p中保存的指针，要小心使用，因为当指针指针释放对象后，这个指针会变成未定义
    7. `swap(p, q)`：交换p和q中的指针
    8. `p.swap(q)`
    
13. `shared_ptr`独有的操作
    1. `make_shared<T>(args)`：返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args来初始化此对象
       1. 这是最安全的分配和使用动态内存的方法
       2. 定义在头文件memory中
       3. 返回指向此对象的shared_ptr
       4. args也就是用来初始化的东西：`shared_ptr<int> p5 = make_shared<int>(42);`
       5. 因为前面对象的类型写的太麻烦了，所以可以用auto来简化
    2. `shared_ptr<T>p(q)`：
    3. `p=q`：会递减p的引用计数，递增q的引用计数，所谓引用计数就是指向的对象被
    4. `p.unique()`如果use_count()为1，则返回true，不然就返回false
    5. `p.use_count()`
    6. 当进行拷贝和赋值的时候，shared_ptr会记录有多少个其他的智能指针指向相同的对象
    7. 每个shared_ptr都有引用计数，当它被拷贝的时候，比如用来初始化其他shared_ptr，作为参数传递给一个函数，或者作为函数的返回值，引用计数都会加1.当它被赋予一个新值或者是shared_ptr被销毁，计数器会递减
    8. 一旦一个shared_ptr的引用计数器变为0，它就会自动释放自己所管理的对象
    9. 当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。他是通过一个特殊的成员函数，析构函数来完成销毁工作的。
    
14. 析构函数一般用来释放对象所分配的资源

15. 因为在最后一个shared_ptr销毁前内存都不会被释放，所以保证shared_ptr在无用之后不再保留就非常重要。

16. 使用动态内存的情景
    1. 程序不知道自己要使用多少对象
       1. 容器类就是因为这个原因才使用的动态内存，所以大小也就可变
    2. 程序不知道所需对象的准确类型
    3. 程序需要在多个对象间共享数据
    
17. 定义StrBlob类
    
    1. 实现一个新的集合类型的最简单的方法是使用某个标准容器来管理元素，采用这种方法，我们可以借助标准库类型来管理元素所使用的内存空间
    
18. 直接管理内存
    1. 定义了2个运算符来分配和释放内存
       1. `new`
       2. `delte`
    2. 相比于只能指针，使用这些更容易出错
    3. 使用new来动态分配和初始化对象
       1. 因为在自由空间分配的内存是无名的，所以new无法为其分配的空间命名，只是返回一个指向该对象的指针
       2. `int *pi = new int;`
       3. 默认情况下，动态分配的对象是默认初始化的，但是我们也可以使用直接初始化方式来初始化一个动态分配的对象：
          1. 传统构造方法，圆括号：`int *pi = new int(1024);`
          2. 列表初始化，花括号：`vector<int> *pv = new vector<int>{0, 1, 2, 3, 4};`
          3. 值初始化：`string *ps = new string();`
             1. 正常是：`string *ps1 = new string;`
             2. 这样初始化，得到的是未定义的值
             3. 但是使用值初始化，也就是后面加个括号，得到的是空字符串，也就是该类型的默认值
             4. 对于构造了自己的构造函数的类类型，两者一样，但是对于内置类型来说，差别很大
       4. 如果使用传统的构造方法，也就是圆括号，就可以使用`auto`。
       5. 可以使用new来初始化一个const对象
       6. 如果`new`不能分配所要求的空间（比如说空间耗尽），会抛出类型为`bad_alloc`的异常。我们可以改变使用的方式来阻止其抛出异常：`int *p2 = new (nothrow) int;`
       7. 6中的new叫做定位new，后面会解释，允许我们传入额外的参数，这里的nothrow就是由标准库定义的名为nothrow的对象，`bad_alloc`和`nothrow`都定义在头文件`new`中
    4. 释放内存
       1. delete包含两个操作
          1. 销毁指针指向的对象
          2. 释放对应的内存
       2. 释放一块非new分配的内存，或者释放多次指针，行为是未定义的
       3. 虽然一个const对象不能被改变，但它本身是可以被销毁的
    5. 动态内存管理常见的问题
       1. 忘记delete内存，会造成内存泄露，这种问题直到内存耗尽才会被发现
       2. 使用已经被释放的对象
       3. 同一块内存释放多次
    
19. share_ptr和new结合使用
    1. 我们不能进行内置指针到智能指针的隐式转换，所以我们不能通过赋值来初始化只能指针，而是只能通过直接初始化
       1. `shared_ptr<int> p1 = new int(1024);`错误
       2. `shared_ptr<int> p2(new int(1024));`正确
    2. 同样的，1中所说的在设定函数返回值时也要小心，如果设定函数返回智能指针，在写返回语句时就不能写返回内置指针
    3. 定义和改变shared_ptr的方法
       1. `shared_ptr<T> p(q)`q是内置指针
       2. `shared_ptr<T> p(u)`u是unique_ptr，赋值后会将u置为空
       3. `shared_ptr<T> p(q, d)`
          1. q是内置指针
          2. d是可调用对象
          3. 这样初始化之后，p将使用d来代替delete
       4. `shared_ptr<T> p(p2, d)`
          1. p2是shared_ptr
       5. `p.reset()`
          1. 这3中都一样
          2. 
       6. `p.reset(q)`
       7. `p.reset(q, d)`
    
20. 不要混合使用智能指针和内置指针

    1. 推荐使用`make_shared`而不是new，这样我们就能在分配对象的同时就将shared_ptr与之绑定，从而避免了将同一块内存绑定到多个独立创建的`shared_ptr`上

    2. 如果在函数的参数传递中混合使用内置指针和智能指针，可能会有意外发生：

       ```c++
       void process(shared_ptr<int> ptr){}
       
       int *x(new int(1024));
       
       process(x);
       process(shared_ptr<int>(x));
       int j = *x; 
       ```

       1. 可以看到，将x直接传入process函数是错误的，因为编译器无法隐式地将内置指针转变成智能指针
       2. 第二个函数调用是对的，但是会造成一个错误：因为智能指针在函数返回后，引用计数会变成0，所以其指向的那块内存会被释放掉，所以x会变成一个空悬指针

    3. 从2中我们知道，当将一个`shared_ptr`绑定到普通指针的时候，我们就将内存管理的责任全部给智能指针了，也就是说我们之后再使用内置指针来访问这块内存时，都会有使用空悬指针的风险，所以不要混用这两种指针

21. 不要使用get来初始化另一个智能指针或者为智能指针赋值

    1. 智能指针定义了一个名为get的函数，可以返回智能指针内部绑定的内置指针
    2. get函数主要是为了这种情况设计的：我们需要向不能使用智能指针的代码传递一个内置指针
    3. 使用get返回的指针的代码不能delete此指针
    4. 虽然没有错误信息提示，但是将另一个智能指针也绑定到get返回的指针上是错误的
    5. get将指针的访问权限传递给代码，只有在保证代码不会delete指针的时候才能使用

22. 其他`shared_ptr`操作

    1. `reset`方法是用来给智能指针绑定另外一个内置指针的时候用的

       1. 需要的话，会释放原来指向的内存

       2. 通常与`unique`一起使用，来控制多个`shared_ptr`共享的对象：在改变底层对象之前，我们检查自己是否是当前对象仅有的用户，如果不是，在改变之前要制作一份新的拷贝

          ```c++
          if (!p.unique())
          	p.reset(new string(*p));
          *p += newVal;
          ```

23. 智能指针和异常

    1. 智能指针能够在函数发生异常提早结束时，仍然能释放内存
    2. 如果使用的是内置指针，因为指针这个局部变量会在函数结束后被销毁，它指向的内存就没办法释放了，也就造成了内存泄漏

24. 智能指针和哑类

    1. 包括标准库在内的很多C++类都定义了析构函数，用来清理对象使用的资源

    2. 但是有些类没有这样好的定义，特别是为C和C++两种语言设计的类，通常要求用户显式地释放所使用的任何资源

    3. 这里使用一个网络库中的对象`connection`来作为例子：

       ```c++
       struct destination;
       struct connection;
       
       connection connect(destination*);
       void disconnect(connection);
       void f(destination &d, ...){
           connection c = connect(&d);
           
       }
       ```

       这里我们可以看到，因为connection没有析构函数，所以在函数结束后，没办法自动关闭连接（也就是调用上面定义的disconnect函数），我们可以使用shared_ptr来保证它被正确关闭：

       ```c++
       void end_connection(connection *p){
           disconnect(*p);
       }
       
       void f(destination &d, ...){
           connection c = connect(&d);
           shared_ptr<connection> p(&c, end_connection);
       }
       ```

       这里也是终于使用了智能指针初始化的第二个参数，是个可调用对象，用来取代delete，作为其析构函数，称为删除器

25. `unique_ptr`

    1. 与`shared_ptr`不同，在给定的某个时刻，只能有一个`unique_ptr`指向一个给定对象

    2. unique_ptr没有像make_shared这类函数，只能传入内置指针来初始化

    3. 由于unique_ptr‘拥有’它所指向的对象，所以它不支持普通的拷贝和赋值操作

       1. 例外1：可以将nullptr赋值给unique_ptr，从而让其释放所指向的对象
       2. 例外2：可以拷贝或赋值一个将要被销毁的unique_ptr，一个常见例子就是函数返回

    4. 可以调用release和reset来将指针的所有权从一个对象转移到另外一个

       ```c++
       unique_ptr<string> p2(p1.release());
       unique_ptr<string> p3(new string("Trex"));
       
       p2.reset(p3.release());
       ```

    5. 传递unique_ptr参数和返回unique_ptr

       1. 下面的代码是合法的，因为这是3中提到的例外2

          ```c++
          unique_ptr<int> clone(int p){
              return unique_ptr<int>(new int(p));
          }
          
          unique_ptr<int> clone(int p){
              unique_ptr<int> ret(new int(p));
              
              return ret;
          }
          ```

    6. 向unique_ptr传入删除器

       1. unique_ptr和shared_ptr一样，都可以在初始化来设定新的删除器，但是unique_ptr在初始化传入时，要规定删除器类型：`unique_ptr<objT, delT> p(new objT, fcn);`
       2. uniqe_ptr不能使用reset来设定新的删除器，这个和shared_ptr是不一样的

    7. weak_ptr

       1. 这是一种不控制所指向对象生存期的智能指针

       2. 它指向由shared_ptr管理的对象，但是它不会改变shared_ptr的引用计数

       3. 我们需要使用shared_ptr来初始化weak_ptr：`weak_ptr<int> wp(make_shared<int>(42));`

       4. 它与内置指针的不同在于：

          1. 初始化：内置指针自己初始化，且可以用来初始化shared_ptr，而weak_ptr用shared_ptr来初始化

          2. 访问对象：内置指针直接解引用来访问，可能因为指向的对象被清除而造成错误。weak_ptr使用lock，返回一个指向共享对象的shared_ptr，会将指向对象的引用+1，可以使用if来判断其指向的对象有没有被清除：比内置指针安全很多

             ```c++
             if (shared_ptr<int> np = wp.lock()){
                 ...
             }
             ```

       5. weak_ptr可以用作伴随指针，也就是组织用户访问一个已经不存在的对象

    8. 指针操作







##### 动态数组

1. C++提供了一种语句，可以让我们一次性分配多个对象

2. 标准库中包含一种名为`allocator`的类，允许我们将分配和初始化分离

3. 使用allocator通常会有更好的性能和更灵活的内存管理能力

4. 不应使用动态分配的数组，而是应该使用标准库容器，因为使用容器的类可以使用默认版本的拷贝，赋值和析构操作。分配动态数组的类必须定义自己版本的操作，在拷贝，赋值以及销毁对象时管理所关联的内存，很麻烦，而且很容易出错

5. 使用new和方括号，方括号内的必须是整型，但是不一定要常量：`int *pia = new int[get_size()];`

6. 可以使用别名：`typedef int arrT[42]; int *p = new arrT;`

7. 分配一个动态数组会得到一个元素类型的指针，而不是数组类型的啥

8. 因为分配的内存不是一个数组类型，所以不能使用begin或者end等迭代器的函数，也不能使用for来遍历数组中的元素

9. 初始化动态分配对象的数组

   1. 既可以默认初始化，也可以值初始化

      ```c++
      int *pia = new int[10];
      int *pia2 =  new int[10]();
      string *psa = new string[10];
      string *psa2 = new string[10]();
      ```

   2. 新标准中还可以提供元素初始化器

   `string *pia3 = new int[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};`

   与内置数组一样，可以部分值初始化，剩下的会默认值初始化

10. 与内置数组不同的一点：可以动态分配一个空数组

11. 释放动态数组

    1. 因为动态数组是一个元素指针，所以不能简单地用`delete p;`，而是应该用`delete [] pa;`，也就是前面加个方括号

12. 智能指针和动态数组

    1. 标准库提供了可以管理动态数组的unique_ptr版本：`unique_ptr<int[]> up(new int[10]);`

    2. 当unique_ptr指向一个动态数组时：

       1. 不能使用点和箭头成员运算符
       2. 可以使用下标运算符来访问数组中的元素

    3. shared_ptr不直接支持管理动态数组，如果希望使用，要自己提供删除器

       `shared_ptr<int> sp(new int[10], [](int *p){delete[] p;});`

    4. 如果不传入自定义的删除器，会使用默认的delete，这样就会带来未知错误

    5. shared_ptr不能使用下标来访问元素

    6. 为了访问数组中的元素，要使用get来获取内置指针，然后用它来访问数组

13. 为什么需要allocator类

    1. new有一些灵活性上的缺陷，因为它把内存分配和对象构造放在了一起，delete也是这样。但是，分配一大块内存时，我们通常计划在这块内存上按需构造对象。也就是先把内存占着，然后在真正需要时才真正执行对象创建操作

14. allocator类

    1. 定义在头文件`memory`中

    2. 提供了一种类型感知的内存分配方法，它分配的内存是原始的，未构造的

    3. 是一个模板，为了定义allocator对象，我们必须指明这个对象可以分配的对象类型。

    4. 当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：

       ```c++
       allocator<string> alloc;
       auto const p = alloc.allocate(n); //分配n个未初始化的string
       ```

    5. 支持的操作

       1. `allocator<T> a`
       2. `a.allocate(n)`分配一段原始未构造的内存，保存n个类型为T的对象
       3. `a.deallocate(p, n)`释放从p开始的内存，这块内存保存了n个类型为T的对象。
          1. p必须是一个先前由allocate返回的指针
          2. n必须是p创建时要求的大小
          3. 在调用这个方法之前，必须对每个在这块内存中创造的对象调用destroy
       4. `a.construct(p, args)`
          1. args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象
       5. `a.destroy(p)`对p所指向的对象执行析构函数

    6. allocator分配未构造的内存

       1. allocateor分配的内存是未构造的
       2. 我们只能对真正构造了的元素进行destroy操作
       3. 标准库还定义了2种伴随算法，定义在头文件memory中
          1. `uninitialized_copy(b, e, b2)`
             1. b和e,b2都是迭代器
             2. 将b,e之间的拷贝到从b2开始
          2. `uninitialized_copy_n(b, n, b2)`
          3. `uninitialized_fill(b, e, t)`
             1. 在b和e之间用t填充
          4. `uninitialized_fill_n(b, n, t)`

##### 使用标准库：文本查询程序

```c++
void runQueries(ifstream &infile){
    TextQuery tq(infile);
    
    while(true){
        cout << "enter word to look for, or q to quit: ";
        string s;
        if (!(cin >> s) || s == "q")
            break;
        print(cout, tq.query(s)) << endl;
    }
}

class QueryResult;
class TextQuery{
public:
    using line_no = std::vector<std::string>::size_type;
    TextQuery(std::ifstream&);
    QueryResult query(const std::string&) const;
    
private:
    std::shared_ptr<std::vector<std::string>> file;
    std::map<std::string, std::shared_ptr<std::set<line_no>>> wm;
};

TextQuery::TextQuery(ifstream &is):file(new vector<string>){
    string text;
    while (getilne(is, text)){
        file->push_back(text);
        int n = file->size() - 1;
        istringstream line(text);
        string word;
        while (line >> word){
            auto &lines = wm[word];
            if (!lines)
                lines.reset(new set<line_no>);
            lines->insert(n);
        }
    }
}

class QueryResult{
friend std::ostream& print(std::ostream&, const QueryResult&);
    
public:
    QueryResult(std::string s,
               std::shared_ptr<std::set<line_no>> p,
               std::shared_ptr<std::vector<std::string>> f):
    	sought(s), lines(p), file(f) {}
    
private:
    std::string sought;
    std::shared_ptr<std::set<line_no>> lines;
    std::shared_ptr<std::vector<std::string>> file;
};

QueryResult TextQuery::query(const string &sought) const{
    static shared_ptr<set<line_no>> nodata(new set<line_no>);
    auto loc = wm.find(sought);
    if (loc == wm.end()
       return QureyResult(sought, nodata, file);
    else
        return QueryResult(sought, loc->second, file);
}
        
ostream &print(ostream &os, const QueryResult &qr){
    os << qr.sought << " occurs " << qr.lines->size() << " "
        << make_plural(qr.lines->size(), "time", "s") << endl;
    
    for (auto num : *qr.lines)
        os << "\t(line " << num + 1 << ") "
        	<< *(qr.file->begin() + num) << endl;
    
    return os;
}
```







### 类设计者的工具

#### 拷贝控制

##### 拷贝，赋值与销毁

1. 当定义一个类的时候，我们要显式地或者隐式地指定在此类型的对象拷贝，移动，赋值和销毁时做什么，我们可以通过定义5中特殊的成员函数来控制这些操作
   1. 拷贝构造函数
   2. 拷贝赋值函数
   3. 移动构造函数
   4. 移动赋值运算符
   5. 析构函数
2. 如果没有定义上面的函数，编译器会自动为他定义缺失的操作，但是这通常不是我们想要的，所以通常要定义这些行为
3. 拷贝构造函数
   1. 如果满足这些条件，这个构造函数就是拷贝构造函数
      1. 第一个参数是自身类类型的引用
      2. 任何额外参数都有默认值
   2. 拷贝构造函数的第一个参数必须是一个引用类型
   3. 每个成员类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝
   4. 例子：
   5. 直接初始化与拷贝初始化
      1. 直接初始化是编译器根据传入的参数来选择相应的构造函数来初始化对象
      2. 拷贝初始化是编译器将右边的数据拷贝进正在创建的对象中
      3. 拷贝初始化使用拷贝构造函数来完成
      4. 如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成
      5. 拷贝初始化在下面的其他情况也会出现：
         1. 将一个对象作为实参传递给一个非引用类型的形参
         2. 从一个返回类型为非引用类型的函数返回一个对象
         3. 用花括号列表初始化一个数组中的元素或一个聚合类的成员
      6. 
4. 拷贝赋值运算符
   1. 

##### 拷贝控制和资源管理

##### 交换操作

##### 拷贝控制示例

##### 动态内存管理类

##### 对象移动



#### 重载运算与类型转换

##### 基本概念

##### 输入和输出运算符

##### 算术和关系运算符

##### 赋值运算符

##### 下标运算符

##### 递增和递减运算符

##### 成员访问运算符

##### 函数调用运算符

##### 重载，类型转换与运算符





#### 面向对象程序设计

##### OOP：概述

##### 定义基类和派生类

##### 虚函数

##### 抽象基类

##### 访问控制与继承

##### 继承中的类作用域

##### 构造函数与拷贝控制

##### 容器与继承

##### 文本查询程序再探



#### 模板与泛型编程

##### 定义模板

##### 模板实参推断

##### 重载与模板

##### 可变参数模板

##### 模板特例化







### 高级主题

#### 标准库特殊设施



#### 用于大型程序的工具



#### 特殊工具与技术